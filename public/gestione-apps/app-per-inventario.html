<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Gestione Ubicazioni - LAPA</title>

  <style>
    :root {
      --bg: #0a0f1c;
      --card: #111827;
      --card-hover: #1f2937;
      --text: #f3f4f6;
      --muted: #9ca3af;
      --border: #374151;
      --accent: #10b981;
      --accent-hover: #059669;
      --danger: #ef4444;
      --warning: #f59e0b;
      --info: #3b82f6;
      --success: #22c55e;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg) 0%, #1a1f2e 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 0;
      overflow-x: hidden;
      font-size: 16px;
      line-height: 1.6;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 20px;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .header-title {
      flex: 1;
      font-size: 22px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .connection-status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
    }

    .connection-status.connected {
      background: rgba(34, 197, 94, 0.1);
      color: var(--success);
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .main-container {
      margin-top: 80px;
      padding: 20px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }

    .scanner-section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      text-align: center;
    }

    .scanner-input {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .input-field {
      flex: 1;
      min-width: 200px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text);
      font-size: 18px;
      font-weight: 600;
      touch-action: manipulation;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(16, 185, 129, 0.05);
    }

    .btn {
      padding: 16px 24px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
      min-height: 48px;
      touch-action: manipulation;
      white-space: nowrap;
    }

    .btn:hover, .btn:focus {
      background: var(--accent-hover);
      transform: scale(1.02);
    }
    
    .btn:active {
      transform: scale(0.98);
      transition: transform 0.1s ease;
    }

    .btn.secondary {
      background: var(--info);
    }

    .btn.secondary:hover, .btn.secondary:focus {
      background: #2563eb;
    }
    
    .btn.secondary:active {
      transform: scale(0.98);
      transition: transform 0.1s ease;
    }

    .location-info {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px 24px;
      margin-bottom: 24px;
      display: none;
    }

    .location-info.active {
      display: block;
    }

    .location-name {
      font-size: 22px;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .location-details {
      color: var(--muted);
      font-size: 16px;
    }

    .products-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 120px;
    }

    /* Ottimizzazioni per tablet 8 pollici (1024x768 o 768x1024) */
    @media (min-width: 768px) and (max-width: 1024px) {
      .products-grid {
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 24px;
      }
      
      .scanner-input {
        gap: 20px;
      }
      
      .btn {
        min-width: 120px;
      }
      
      .main-container {
        padding: 24px;
      }
      
      .header {
        padding: 0 24px;
      }
      
      /* Miglioramenti touch per tablet */
      .product-card {
        padding: 16px;
        min-height: 200px;
      }
      
      .product-image {
        width: 50px;
        height: 50px;
      }
      
      .input-field {
        min-height: 56px;
      }
      
      .btn {
        min-height: 56px;
        padding: 18px 28px;
      }
      
      .search-result-item {
        min-height: 80px;
        padding: 20px;
      }
    }
    
    @media (max-width: 768px) {
      .products-grid {
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 16px;
      }
      
      .scanner-input {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btn {
        width: 100%;
        margin-bottom: 8px;
      }
      
      .input-field {
        min-width: auto;
      }
    }

    .product-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-height: 180px;
      touch-action: manipulation;
      text-align: center;
    }

    .product-card:hover, .product-card:focus {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border-color: var(--accent);
    }
    
    .product-card:active {
      transform: translateY(-1px);
      transition: transform 0.1s ease;
    }

    .product-card.selected {
      border-color: var(--accent);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1));
    }
    
    .product-card.counted-recent {
      /* Rimosso effetto nebbiato - troppo scuro */
      border-color: var(--info);
      background: rgba(59, 130, 246, 0.1);
    }
    
    .product-card.counted-recent::after {
      content: 'üïê';
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 14px;
      background: var(--info);
      border-radius: 50%;
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .product-image {
      width: 70px;
      height: 70px;
      object-fit: cover;
      border-radius: 8px;
      background: var(--border);
      margin: 0 auto 10px auto;
      display: block;
      filter: brightness(0.85) contrast(1.0) saturate(1.0);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .product-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 6px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      min-height: 36px;
      line-height: 1.4;
    }

    .product-code {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .product-qty {
      font-size: 16px;
      color: var(--accent);
      font-weight: 700;
    }

    .product-lot {
      font-size: 12px;
      color: var(--warning);
      margin-top: 4px;
    }
    
    .product-status {
      font-size: 10px;
      color: var(--info);
      margin-top: 4px;
      padding: 2px 6px;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 4px;
      display: inline-block;
    }
    
    .product-last-count {
      font-size: 10px;
      color: var(--muted);
      margin-top: 2px;
    }
    
    .product-user {
      font-size: 10px;
      color: var(--accent);
      margin-top: 2px;
    }

    .bottom-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card);
      border-top: 1px solid var(--border);
      padding: 20px;
      display: none;
      z-index: 999;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
      max-height: 70vh;
      overflow-y: auto;
    }

    .bottom-panel.active {
      display: block;
    }
    
    /* Quando bottom panel √® aperto, aggiungi padding al main per evitare sovrapposizioni */
    body:has(.bottom-panel.active) .main-container {
      padding-bottom: 400px;
    }
    
    /* Fallback per browser che non supportano :has() */
    .main-container.panel-open {
      padding-bottom: 400px;
    }

    .selected-product {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 15px;
    }

    .selected-product-image {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 12px;
      background: var(--border);
      filter: brightness(0.85) contrast(1.0) saturate(1.0);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .selected-product-info {
      flex: 1;
    }

    .selected-product-name {
      font-weight: 600;
      font-size: 20px;
      margin-bottom: 6px;
    }

    .selected-product-details {
      color: var(--muted);
      font-size: 16px;
    }

    .action-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .input-group {
      display: flex;
      gap: 10px;
      align-items: center;
      flex: 1;
    }

    .input-label {
      color: var(--muted);
      font-size: 16px;
      min-width: 120px;
    }

    .notification {
      position: fixed;
      top: 100px;
      right: 20px;
      padding: 20px 28px;
      border-radius: 16px;
      font-weight: 600;
      font-size: 16px;
      animation: slideIn 0.3s ease;
      z-index: 2000;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      max-width: 400px;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .notification.success {
      background: var(--success);
      color: white;
    }

    .notification.error {
      background: var(--danger);
      color: white;
    }

    .notification.warning {
      background: var(--warning);
      color: white;
    }

    .notification.info {
      background: var(--info);
      color: white;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--border);
      border-top: 4px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }

    .empty-state-icon {
      font-size: 80px;
      margin-bottom: 24px;
    }

    .empty-state-title {
      font-size: 28px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 12px;
    }

    .empty-state-description {
      font-size: 18px;
    }

    .scanner-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 4000;
    }

    .scanner-modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .scanner-content {
      background: var(--card);
      border-radius: 16px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
    }

    .scanner-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .scanner-title {
      font-size: 22px;
      font-weight: 600;
    }

    .close-scanner {
      background: var(--danger);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
      touch-action: manipulation;
    }

    #reader {
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
    }

    .manual-input {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    .search-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
      display: none;
    }

    .search-panel.active {
      display: block;
    }

    .search-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .search-tab {
      padding: 8px 16px;
      background: var(--border);
      border: none;
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .search-tab.active {
      background: var(--accent);
      color: white;
    }

    .search-input {
      width: 100%;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text);
      font-size: 18px;
      touch-action: manipulation;
    }

    .search-results {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .search-result-item {
      padding: 16px;
      background: var(--card-hover);
      border: 1px solid var(--border);
      border-radius: 12px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      gap: 16px;
      align-items: center;
      touch-action: manipulation;
      min-height: 60px;
    }

    .search-result-item:hover, .search-result-item:focus {
      background: rgba(16, 185, 129, 0.15);
      border-color: var(--accent);
    }
    
    .search-result-item:active {
      background: rgba(16, 185, 129, 0.25);
      transform: scale(0.99);
      transition: transform 0.1s ease;
    }

    .search-result-image {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 8px;
      background: var(--border);
      filter: brightness(0.85) contrast(1.0) saturate(1.0);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .search-result-info {
      flex: 1;
    }

    .search-result-name {
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 16px;
    }

    .search-result-details {
      font-size: 14px;
      color: var(--muted);
    }

    .transfer-section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
      display: none;
    }

    .transfer-section.active {
      display: block;
    }

    .transfer-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 15px;
    }

    .transfer-info {
      background: var(--card-hover);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .transfer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }

    .transfer-label {
      color: var(--muted);
    }

    .transfer-value {
      color: var(--text);
      font-weight: 600;
    }

    .confirm-section {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    .confirm-message {
      color: var(--warning);
      font-weight: 600;
      text-align: center;
      margin-bottom: 15px;
    }

    .lot-selector {
      background: var(--card-hover);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin: 10px 0;
    }

    .lot-selector.required {
      border-color: var(--warning);
      background: rgba(245, 158, 11, 0.1);
    }

    .lot-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }

    .lot-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .lot-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .lot-option:hover, .lot-option:focus {
      border-color: var(--accent);
      background: rgba(16, 185, 129, 0.1);
    }
    
    .lot-option:active {
      background: rgba(16, 185, 129, 0.2);
      transform: scale(0.99);
      transition: transform 0.1s ease;
    }

    .lot-option.selected {
      border-color: var(--accent);
      background: rgba(16, 185, 129, 0.2);
    }

    .lot-radio {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid var(--border);
      position: relative;
    }

    .lot-option.selected .lot-radio {
      border-color: var(--accent);
    }

    .lot-option.selected .lot-radio::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
    }

    .lot-info {
      flex: 1;
    }

    .lot-name {
      font-weight: 600;
      color: var(--text);
    }

    .lot-qty {
      font-size: 12px;
      color: var(--muted);
    }
  
  /* Calcolatrice */
  #calculatorModal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
  }

  .calculator {
    background: var(--card);
    border: 2px solid var(--accent);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    width: 100%;
    max-width: 320px;
  }

  .calculator-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    color: var(--accent);
    font-weight: 700;
    font-size: 18px;
  }

  .calculator-close {
    background: transparent;
    border: none;
    color: var(--danger);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    touch-action: manipulation;
  }

  .calc-display {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    font-size: 28px;
    font-weight: 700;
    text-align: right;
    margin-bottom: 20px;
    color: var(--text);
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
  }

  .calc-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
  }

  .calc-button {
    background: var(--border);
    border: none;
    border-radius: 12px;
    padding: 18px;
    font-size: 20px;
    font-weight: 700;
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s;
    min-height: 60px;
    touch-action: manipulation;
  }

  .calc-button:hover, .calc-button:focus {
    background: var(--accent);
    transform: scale(1.05);
  }

  .calc-button:active {
    transform: scale(0.95);
  }

  .calc-button.operator {
    background: var(--info);
    color: white;
  }

  .calc-button.clear {
    background: var(--danger);
    color: white;
    grid-column: span 2;
  }

  .calc-button.zero {
    grid-column: span 2;
  }

  .calc-button.equals {
    background: var(--success);
    color: white;
    grid-column: span 2;
  }

  .calc-actions {
    display: flex;
    gap: 12px;
    margin-top: 20px;
  }

  .calc-action-btn {
    flex: 1;
    padding: 16px;
    border: none;
    border-radius: 12px;
    font-weight: 700;
    cursor: pointer;
    font-size: 16px;
    min-height: 50px;
    touch-action: manipulation;
  }

  .calc-confirm {
    background: var(--success);
    color: white;
  }

  .calc-cancel {
    background: var(--danger);
    color: white;
  }

  .calc-btn {
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    min-width: 45px;
    height: 45px;
    touch-action: manipulation;
  }

  .calc-btn:hover, .calc-btn:focus {
    background: var(--accent-hover);
    transform: scale(1.05);
  }

  .calc-btn:active {
    transform: scale(0.95);
  }

  .qty-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .qty-wrapper input {
    flex-grow: 1;
  }
  
  </style>



  <div class="header">
    <div class="header-title">
      <span>üìç Gestione Ubicazioni</span>
      <span style="color: var(--muted); font-size: 14px; font-weight: normal;">
        | Scanner ‚Üí Prodotti ‚Üí Modifica
      </span>
    </div>
    <div id="connectionStatus" class="connection-status disconnected">
      <span class="status-dot"></span>
      <span id="statusText">Non connesso</span>
    </div>
  </div>

  <div class="main-container">
    
    <div class="scanner-section">
      <div class="scanner-input">
        <input type="text" id="locationScanner" class="input-field" placeholder="Scansiona o inserisci codice ubicazione">
        <button class="btn" onclick="openLocationScanner()">üì∑ Camera</button>
        <button class="btn secondary" onclick="openProductSearch()">üîç Aggiungi Prodotto</button>
        <button class="btn secondary" onclick="focusLocationField()" title="Focalizza campo per scanner">‚å®Ô∏è</button>
      </div>
      <div style="font-size: 16px; color: var(--muted);">
        üì± Usa pistola scanner o fotocamera per leggere il barcode dell'ubicazione
      </div>
    </div>

    
    <div id="locationInfo" class="location-info">
      <div id="locationName" class="location-name"></div>
      <div id="locationDetails" class="location-details"></div>
    </div>

    
    <div id="searchPanel" class="search-panel">
      <div class="scanner-header">
        <span class="scanner-title">üîç Aggiungi Prodotto all'Ubicazione</span>
        <button class="close-scanner" onclick="closeProductSearch()">‚úï</button>
      </div>
      <div style="padding: 15px; border-bottom: 1px solid var(--border); background: rgba(245, 158, 11, 0.1);">
        <div style="color: var(--warning); font-weight: 600; text-align: center;">
          üìç Ubicazione: <span id="currentLocationName">-</span>
        </div>
        <div style="font-size: 14px; color: var(--muted); text-align: center; margin-top: 4px;">
          Cerca un prodotto da aggiungere a questa ubicazione
        </div>
      </div>
      <div style="padding: 15px;">
        <input type="text" id="searchInput" class="search-input" placeholder="Cerca prodotto per nome, codice o barcode...">
        <div id="searchResults" class="search-results">
          <div style="text-align: center; color: var(--muted); padding: 20px;">
            Inserisci almeno 3 caratteri per iniziare la ricerca
          </div>
        </div>
      </div>
    </div>

    
    <div id="transferSection" class="transfer-section">
      <div class="transfer-title">üöö Trasferimento da Buffer</div>
      <div class="transfer-info">
        <div class="transfer-item">
          <span class="transfer-label">Prodotto:</span>
          <span id="transferProductName" class="transfer-value">-</span>
        </div>
        <div class="transfer-item">
          <span class="transfer-label">Quantit√† disponibile nel buffer:</span>
          <span id="transferBufferQty" class="transfer-value">-</span>
        </div>
        <div class="transfer-item">
          <span class="transfer-label">Ubicazione destinazione:</span>
          <span id="transferDestLocation" class="transfer-value">-</span>
        </div>
      </div>
      <div style="display: grid; gap: 16px; margin-bottom: 20px;">
        <div>
          <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">LOTTO/SERIE *</label>
          <input type="text" id="transferLotNumber" class="input-field" placeholder="Inserisci numero lotto" style="padding: 16px; font-size: 16px;">
        </div>
        <div>
          <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">SCADENZA (opzionale)</label>
          <input type="date" id="transferExpiryDate" class="input-field" style="padding: 16px; font-size: 16px;">
        </div>
        <div>
          <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">QUANTIT√Ä</label>
          <div class="qty-wrapper">
            <input type="number" id="transferQty" class="input-field" min="0.01" step="0.01" placeholder="0" style="padding: 16px; font-size: 16px; border: 2px solid var(--accent); font-weight: 600;" readonly="">
            <button class="calc-btn" onclick="openTransferCalculator()" title="Apri calcolatrice">üî¢</button>
          </div>
        </div>
      </div>
      <div class="action-row">
        <button class="btn" onclick="executeTransferFromBuffer()">Trasferisci</button>
        <button class="btn secondary" onclick="cancelTransfer()">Annulla</button>
      </div>
    </div>

    
    <div id="productsGrid" class="products-grid">
      
    </div>

    
    <div id="emptyState" class="empty-state" style="display: none;">
      <div class="empty-state-icon">üì¶</div>
      <div class="empty-state-title">Nessun prodotto trovato</div>
      <div class="empty-state-description" id="emptyDescription">
        Scansiona un'ubicazione per vedere i prodotti contenuti
      </div>
    </div>

    
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
      <div class="loading-spinner"></div>
    </div>
  </div>

  
  <div id="bottomPanel" class="bottom-panel">
    <div class="selected-product">
      <img id="selectedImage" class="selected-product-image" src="" loading="lazy">
      <div class="selected-product-info">
        <div id="selectedName" class="selected-product-name"></div>
        <div id="selectedDetails" class="selected-product-details"></div>
      </div>
    </div>
    
    
    <div class="action-row" style="background: var(--card-hover); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
      <div class="input-group">
        <span class="input-label">Giacenza sistema:</span>
        <span id="systemQuantity" style="color: var(--info); font-weight: 600; font-size: 18px;">0</span>
        <span id="systemUom" style="color: var(--muted);">PZ</span>
      </div>
    </div>
    
    
    <div style="display: grid; gap: 16px; margin-bottom: 20px;">
      <div>
        <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">LOTTO/SERIE *</label>
        <input type="text" id="lotNumberInput" class="input-field" placeholder="Inserisci numero lotto (obbligatorio)" style="padding: 16px; font-size: 16px; border: 2px solid var(--warning);">
      </div>
      <div>
        <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">SCADENZA (opzionale)</label>
        <input type="date" id="expiryDateInput" class="input-field" style="padding: 16px; font-size: 16px; -webkit-appearance: none; touch-action: manipulation; min-height: 48px;">
      </div>
      <div>
        <label style="display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px;">QUANTIT√Ä CONTATA</label>
        <div class="qty-wrapper">
          <input type="number" id="countedInput" class="input-field" min="0" step="0.01" placeholder="Inserisci quantit√† fisica (anche 0)" style="padding: 16px; font-size: 16px; border: 2px solid var(--accent); font-weight: 600;" oninput="updateDifferenceIndicator()" onkeyup="updateDifferenceIndicator()" onchange="updateDifferenceIndicator()" readonly="">
          <button class="calc-btn" onclick="openCalculator()" title="Apri calcolatrice">üî¢</button>
        </div>
        <span id="uomLabel" style="color: var(--muted); font-size: 14px; margin-left: 8px;">PZ</span>
      </div>
    </div>
    
    
    <div id="differenceIndicator" class="action-row" style="display: none; background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 8px; margin: 10px 0;">
      <div class="input-group" style="justify-content: center;">
        <span style="color: var(--warning); font-weight: 600;">üìä Differenza: <span id="differenceValue">0</span> <span id="differenceUom">PZ</span></span>
      </div>
    </div>
    
    
    
    <div class="confirm-section">
      <div class="confirm-message">üìù Salva il conteggio fisico</div>
      <div style="font-size: 14px; color: var(--muted); text-align: center; margin-bottom: 12px;">
        Il responsabile convalider√† dall'interfaccia Odoo
      </div>
      <div class="action-row">
        <button class="btn secondary" onclick="cancelSelection()">Annulla</button>
        <button id="confirmBtn" class="btn" onclick="confirmQuantityChange()" style="flex: 1;">
          üíæ Salva Conteggio
        </button>
      </div>
    </div>
  </div>

  
  <div id="lotSelectionModal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 3100;">
    <div style="background: var(--card); border: 2px solid var(--accent); border-radius: 20px; padding: 20px; max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="color: var(--accent); margin: 0;">üè∑Ô∏è Seleziona Lotto da Contare</h3>
        <button onclick="closeLotSelection()" style="background: transparent; border: none; color: var(--danger); font-size: 24px; cursor: pointer;">√ó</button>
      </div>
      
      <div id="productNameForLots" style="font-weight: 600; margin-bottom: 15px; color: var(--text);"></div>
      
      <div id="lotsList" style="display: flex; flex-direction: column; gap: 10px;">
        
      </div>
    </div>
  </div>
  
  
  <div id="calculatorModal">
    <div class="calculator">
      <div class="calculator-header">
        <span id="calculatorTitle">üî¢ Calcolatrice</span>
        <button class="calculator-close" onclick="closeCalculator()">√ó</button>
      </div>
      
      <div class="calc-display" id="calcDisplay">0</div>
      
      <div class="calc-buttons">
        <button class="calc-button clear" onclick="clearCalc()">C</button>
        <button class="calc-button operator" onclick="appendToCalc('/'))">√∑</button>
        <button class="calc-button operator" onclick="appendToCalc('*')">√ó</button>
        <button class="calc-button" onclick="deleteLastCalc()">‚å´</button>
        
        <button class="calc-button" onclick="appendToCalc('7')">7</button>
        <button class="calc-button" onclick="appendToCalc('8')">8</button>
        <button class="calc-button" onclick="appendToCalc('9')">9</button>
        <button class="calc-button operator" onclick="appendToCalc('-')">-</button>
        
        <button class="calc-button" onclick="appendToCalc('4')">4</button>
        <button class="calc-button" onclick="appendToCalc('5')">5</button>
        <button class="calc-button" onclick="appendToCalc('6')">6</button>
        <button class="calc-button operator" onclick="appendToCalc('+')">+</button>
        
        <button class="calc-button" onclick="appendToCalc('1')">1</button>
        <button class="calc-button" onclick="appendToCalc('2')">2</button>
        <button class="calc-button" onclick="appendToCalc('3')">3</button>
        <button class="calc-button" onclick="appendToCalc('.')">,</button>
        
        <button class="calc-button zero" onclick="appendToCalc('0')">0</button>
        <button class="calc-button equals" onclick="calculateResult()">=</button>
      </div>
      
      <div class="calc-actions">
        <button class="calc-action-btn calc-confirm" onclick="confirmCalculation()">‚úÖ Conferma</button>
        <button class="calc-action-btn calc-cancel" onclick="closeCalculator()">‚ùå Annulla</button>
      </div>
    </div>
  </div>

  
  <div id="scannerModal" class="scanner-modal">
    <div class="scanner-content">
      <div class="scanner-header">
        <span class="scanner-title" id="scannerTitle">üì∑ Scanner</span>
        <button class="close-scanner" onclick="closeScanner()">‚úï</button>
      </div>
      <div id="reader"></div>
      <div class="manual-input">
        <input type="text" id="manualCode" class="input-field" placeholder="Oppure inserisci codice manuale">
        <button class="btn" onclick="useManualCode()">OK</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
  <script>
    // Configurazione
    const CONFIG = {
      bufferLocation: {
        id: 8,  // ID dell'ubicazione buffer in Odoo
        name: 'WH/Stock/Buffer'
      },
      refreshInterval: 30000,
      defaultUOM: 'PZ'
    };

    // Stato applicazione
    console.log('üöÄüöÄüöÄ APP INVENTARIO INIZIALIZZATA! üöÄüöÄüöÄ');
    console.log('üìç URL corrente:', window.location.href);
    console.log('üìç Origin:', window.location.origin);

    let appState = {
      currentLocation: null,
      products: [],
      selectedProduct: null,
      selectedLot: null,
      scanner: null,
      scannerActive: false,
      scannerMode: 'location', // 'location' o 'product'
      searchMode: 'location', // 'location' o 'warehouse'
      transferProduct: null,
      currentUser: null // Utente corrente loggato
    };

    // Funzioni Odoo RPC
    function csrf() {
      try {
        if (window.odoo && window.odoo.csrf_token) {
          return window.odoo.csrf_token;
        }
        if (window.parent && window.parent.odoo && window.parent.odoo.csrf_token) {
          return window.parent.odoo.csrf_token;
        }
        const meta = document.querySelector('meta[name="csrf-token"]');
        if (meta) return meta.content;
        
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
          const [name, value] = cookie.trim().split('=');
          if (name === 'csrf_token') return decodeURIComponent(value);
        }
      } catch (e) {
        console.error('CSRF token error:', e);
      }
      return null;
    }

    async function rpc(model, method, args) {
      const token = csrf();
      if (!token) {
        throw new Error('CSRF token non trovato');
      }

      const response = await fetch('/web/dataset/call_kw', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': token
        },
        credentials: 'include',
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'call',
          params: {
            model: model,
            method: method,
            args: args,
            kwargs: {}
          },
          id: Math.floor(Math.random() * 1000000000)
        })
      });

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error.data?.message || data.error.message || 'Errore RPC');
      }
      return data.result;
    }

    async function searchRead(model, domain, fields, limit = false) {
      const args = [domain, fields];
      if (limit) args.push(0, limit);
      return await rpc(model, 'search_read', args);
    }

    // Gestione scanner ubicazione
    async function scanLocation(locationCode) {
      console.log('üöÄ FUNZIONE scanLocation CHIAMATA con:', locationCode);

      if (!locationCode) {
        console.log('‚ùå Codice ubicazione vuoto');
        showNotification('Inserisci un codice ubicazione', 'error');
        return;
      }

      console.log('‚úÖ Codice valido, procedo...');

      try {
        showLoading();
        console.log('üîç Cercando ubicazione:', locationCode);
        console.log('üìç URL API:', window.location.origin + '/api/inventory/location');

        // Usa la API che funziona (stesse credenziali del catalogo)
        const response = await fetch('/api/inventory/location', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            locationCode: locationCode
          })
        });

        console.log('üì° Risposta fetch:', response.status, response.statusText);
        console.log('üì° Response headers:', response.headers);

        const responseText = await response.text();
        console.log('üì° Raw response:', responseText);

        let data;
        try {
          data = JSON.parse(responseText);
        } catch (parseError) {
          console.error('‚ùå Errore parsing JSON:', parseError);
          console.error('‚ùå Response text:', responseText);
          throw new Error('Risposta non valida dal server');
        }

        console.log('üì¶ Dati ricevuti:', data);

        if (!data.success) {
          console.error('‚ùå Errore dal server:', data.error);
          console.error('‚ùå Dettagli:', data.details);
          throw new Error(data.error || 'Errore nella ricerca ubicazione');
        }

        const location = data.location;
        const inventory = data.inventory || [];

        appState.currentLocation = location;

        // Aggiorna UI ubicazione
        document.getElementById('locationInfo').classList.add('active');
        document.getElementById('locationName').textContent = location.complete_name || location.name;
        document.getElementById('locationDetails').textContent = `Codice: ${location.barcode || location.name}`;

        // I prodotti sono gi√† nell'inventory restituito dall'API
        console.log('üì¶ Prodotti gi√† caricati dall\'API:', inventory.length);
        console.log('üì¶ INVENTORY COMPLETO:', JSON.stringify(inventory.slice(0,5)));

        // Verifica se ci sono quantit√† > 0
        const conGiacenza = inventory.filter(p => p.quantity > 0);
        console.log('üü¢ Prodotti CON giacenza:', conGiacenza.length);
        console.log('üü¢ Esempi con giacenza:', conGiacenza.slice(0,3));

        displayProducts(inventory);

        // Pulisci il campo e mantieni il focus
        document.getElementById('locationScanner').value = '';
        document.getElementById('locationScanner').focus();

        showNotification(`‚úÖ Ubicazione: ${location.name} (${inventory.length} prodotti)`, 'success');

      } catch (error) {
        console.error('‚ùå ERRORE COMPLETO scan ubicazione:', error);
        console.error('‚ùå Tipo errore:', error.name);
        console.error('‚ùå Messaggio:', error.message);
        console.error('‚ùå Stack:', error.stack);
        showNotification('Errore: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }

    // Mostra i prodotti nell'interfaccia
    function displayProducts(inventory) {
      console.log('üì¶ Mostrando', inventory.length, 'prodotti');
      console.log('üì¶ Dati inventario ricevuti:', inventory);

      // Salva i prodotti nello stato
      appState.products = inventory.map(item => {
        console.log('Prodotto:', item.product_id[1], 'Quantit√†:', item.quantity);
        return {
          id: item.product_id[0],
          name: item.product_id[1],
          quantity: parseFloat(item.quantity) || 0,
          reserved: parseFloat(item.reserved_quantity) || 0,
          lot_id: item.lot_id
        };
      });

      // Aggiorna l'interfaccia
      const container = document.getElementById('productsGrid');
      if (!container) {
        console.error('‚ùå Elemento productsGrid non trovato!');
        return;
      }

      if (appState.products.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">üì¶</div>
            <div class="empty-title">Ubicazione vuota</div>
            <div class="empty-description">
              Nessun prodotto in questa ubicazione
            </div>
          </div>
        `;
        return;
      }

      container.innerHTML = appState.products.map(product => {
        const bgColor = product.quantity > 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.05)';
        const borderColor = product.quantity > 0 ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.2)';

        return `
          <div class="product-card" onclick="selectProduct(${product.id})"
               style="background: ${bgColor}; border: 1px solid ${borderColor}; cursor: pointer; transition: all 0.3s;">
            <div class="product-info">
              <div class="product-name" style="font-weight: 600;">${product.name}</div>
              <div class="product-details" style="color: #9ca3af; font-size: 14px; margin-top: 4px;">
                ${product.lot_id ? `üìã Lotto: ${product.lot_id[1] || product.lot_id}` : ''}
              </div>
            </div>
            <div class="product-quantity" style="text-align: center;">
              <div class="quantity-value" style="font-size: 32px; font-weight: bold; color: ${product.quantity > 0 ? '#10b981' : '#ef4444'};">
                ${product.quantity}
              </div>
              <div class="quantity-label" style="font-size: 12px; color: #6b7280;">Disponibili</div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Carica prodotti dell'ubicazione (VECCHIA - non pi√π usata)
    async function loadLocationProducts(locationId) {
      try {
        // Ottieni quants dall'ubicazione con informazioni complete
        const quants = await searchRead(
          'stock.quant',
          [
            ['location_id', '=', locationId],
            ['quantity', '>', 0]
          ],
          [
            'product_id', 
            'quantity', 
            'lot_id', 
            'inventory_quantity', 
            'inventory_date', 
            'inventory_diff_quantity',
            'user_id',
            'package_id',
            'product_uom_id'
          ],
          false
        );

        console.log(`Trovati ${quants.length} quants nell'ubicazione`);

        // Raggruppa per prodotto
        const productMap = new Map();

        for (const quant of quants) {
          const productId = quant.product_id[0];

          if (!productMap.has(productId)) {
            // Ottieni dettagli prodotto
            const products = await searchRead(
              'product.product',
              [['id', '=', productId]],
              ['name', 'default_code', 'barcode', 'image_128', 'uom_id'],
              1
            );

            if (products.length > 0) {
              const product = products[0];
              productMap.set(productId, {
                id: productId,
                name: product.name,
                code: product.default_code || product.barcode || '',
                image: product.image_128 ? `data:image/png;base64,${product.image_128}` : null,
                uom: product.uom_id ? product.uom_id[1] : CONFIG.defaultUOM,
                uom_id: product.uom_id ? product.uom_id[0] : null,
                totalQty: 0,
                lots: [],
                lastCountDate: null,
                lastCountUser: null,
                inventoryQuantity: null,
                inventoryDiff: null,
                isCounted: false,
                isCountedRecent: false
              });
            }
          }

          const productData = productMap.get(productId);
          if (productData) {
            productData.totalQty += quant.quantity;
            
            // Aggiorna informazioni conteggio se esiste inventory_quantity
            if (quant.inventory_quantity !== null && quant.inventory_quantity !== false) {
              productData.inventoryQuantity = quant.inventory_quantity;
              productData.inventoryDiff = quant.inventory_diff_quantity || 0;
              
              if (quant.inventory_date) {
                productData.lastCountDate = quant.inventory_date;
                
                // Calcola se √® stato contato negli ultimi 5 giorni
                const countDate = new Date(quant.inventory_date);
                const today = new Date();
                const fiveDaysAgo = new Date(today.getTime() - (5 * 24 * 60 * 60 * 1000));
                
                productData.isCountedRecent = countDate >= fiveDaysAgo;
                productData.isCounted = true; // Mantieni per compatibilit√†
              }
              
              if (quant.user_id && quant.user_id[1]) {
                productData.lastCountUser = quant.user_id[1];
              }
            }

            if (quant.lot_id) {
              const existingLot = productData.lots.find(l => l.id === quant.lot_id[0]);
              if (existingLot) {
                existingLot.qty += quant.quantity;
                
                // Aggiorna anche i dati di conteggio se presenti
                if (quant.inventory_quantity !== null && quant.inventory_quantity !== false) {
                  existingLot.inventoryQuantity = quant.inventory_quantity;
                  existingLot.lastCountDate = quant.inventory_date;
                  existingLot.lastCountUser = quant.user_id ? quant.user_id[1] : null;
                  existingLot.inventoryDiff = quant.inventory_diff_quantity || null;
                  
                  // Calcola se questo lotto √® stato contato di recente
                  if (existingLot.lastCountDate) {
                    const countDate = new Date(existingLot.lastCountDate);
                    const today = new Date();
                    const fiveDaysAgo = new Date(today.getTime() - (5 * 24 * 60 * 60 * 1000));
                    existingLot.isCountedRecent = countDate >= fiveDaysAgo;
                  }
                }
              } else {
                // Carica dettagli lotto inclusa scadenza
                const lotDetails = await searchRead(
                  'stock.lot',
                  [['id', '=', quant.lot_id[0]]],
                  ['id', 'name', 'expiration_date'],
                  1
                );
                
                const lotData = {
                  id: quant.lot_id[0],
                  name: quant.lot_id[1],
                  qty: quant.quantity,
                  expiry_date: null,
                  // Informazioni conteggio per questo lotto
                  inventoryQuantity: quant.inventory_quantity,
                  lastCountDate: quant.inventory_date,
                  lastCountUser: quant.user_id ? quant.user_id[1] : null,
                  inventoryDiff: quant.inventory_diff_quantity || null,
                  isCountedRecent: false // Verr√† calcolato dopo
                };
                
                if (lotDetails && lotDetails.length > 0 && lotDetails[0].expiration_date) {
                  lotData.expiry_date = lotDetails[0].expiration_date;
                }
                
                // Calcola se questo lotto √® stato contato di recente
                if (lotData.lastCountDate) {
                  const countDate = new Date(lotData.lastCountDate);
                  const today = new Date();
                  const fiveDaysAgo = new Date(today.getTime() - (5 * 24 * 60 * 60 * 1000));
                  lotData.isCountedRecent = countDate >= fiveDaysAgo;
                }
                
                productData.lots.push(lotData);
              }
            } else {
              const noLot = productData.lots.find(l => !l.id);
              if (noLot) {
                noLot.qty += quant.quantity;
              } else {
                productData.lots.push({
                  id: null,
                  name: 'Senza lotto',
                  qty: quant.quantity
                });
              }
            }
          }
        }

        appState.products = Array.from(productMap.values());
        renderProducts();
        
        // Mantieni focus sul campo ubicazione per scansioni consecutive
        setTimeout(() => {
          const locationInput = document.getElementById('locationScanner');
          if (locationInput) {
            locationInput.focus();
          }
        }, 100);

      } catch (error) {
        console.error('Errore caricamento prodotti:', error);
        showNotification('Errore nel caricamento dei prodotti', 'error');
      }
    }

    // Renderizza griglia prodotti
    function renderProducts() {
      const grid = document.getElementById('productsGrid');
      const emptyState = document.getElementById('emptyState');
      const emptyDescription = document.getElementById('emptyDescription');

      if (appState.products.length === 0) {
        grid.style.display = 'none';
        emptyState.style.display = 'block';
        
        if (appState.currentLocation) {
          emptyDescription.textContent = `Nessun prodotto trovato in: ${appState.currentLocation.name}`;
        } else {
          emptyDescription.textContent = 'Scansiona un\'ubicazione per vedere i prodotti contenuti';
        }
        
        return;
      }

      grid.style.display = 'grid';
      emptyState.style.display = 'none';

      // Ordina prodotti: non contati prima, poi contati recenti (ultimi 5 giorni) in fondo
      const sortedProducts = [...appState.products].sort((a, b) => {
        // Prima: prodotti mai contati
        if (!a.isCounted && b.isCounted) return -1;
        if (a.isCounted && !b.isCounted) return 1;
        
        // Poi: tra i contati, quelli recenti (ultimi 5 giorni) vanno dopo
        if (a.isCounted && b.isCounted) {
          if (a.isCountedRecent && !b.isCountedRecent) return 1;
          if (!a.isCountedRecent && b.isCountedRecent) return -1;
          
          // Se entrambi sono contati recenti o entrambi vecchi, ordina per data (pi√π recenti prima)
          if (a.lastCountDate && b.lastCountDate) {
            return new Date(b.lastCountDate) - new Date(a.lastCountDate);
          }
        }
        
        return 0;
      });
      
      grid.innerHTML = sortedProducts.map(product => {
        const lotInfo = product.lots.length > 0 ? 
          product.lots.map(l => `${l.name}: ${l.qty}`).join(', ') : '';
        
        const countedClass = product.isCountedRecent ? 'counted-recent' : '';
        
        // Formatta data ultimo conteggio
        const lastCountInfo = product.lastCountDate ? 
          new Date(product.lastCountDate).toLocaleDateString('it-IT', {
            day: '2-digit', month: '2-digit', year: '2-digit',
            hour: '2-digit', minute: '2-digit'
          }) : 'Mai contato';
          
        const userInfo = product.lastCountUser ? product.lastCountUser : 'N/A';
        
        let statusInfo;
        if (product.isCountedRecent) {
          const daysAgo = Math.ceil((new Date() - new Date(product.lastCountDate)) / (1000 * 60 * 60 * 24));
          statusInfo = `<div class="product-status">üïê Contato ${daysAgo}g fa</div>`;
        } else if (product.isCounted) {
          statusInfo = `<div class="product-status">‚úì Contato (vecchio)</div>`;
        } else {
          statusInfo = `<div class="product-status">‚è≥ Da contare</div>`;
        }
        
        const diffInfo = product.inventoryDiff !== null && product.isCounted ? 
          `<div class="product-last-count">Diff: ${product.inventoryDiff > 0 ? '+' : ''}${product.inventoryDiff}</div>` : '';

        return `
          <div class="product-card ${countedClass}" onclick="selectProduct(${product.id})">
            ${product.image ? 
              `<img src="${product.image}" class="product-image" alt="${product.name}">` :
              `<div class="product-image" style="display:flex;align-items:center;justify-content:center;font-size:32px;margin:0 auto 10px auto;">üì¶</div>`
            }
            <div class="product-name">${product.name}</div>
            ${product.code ? `<div class="product-code">${product.code}</div>` : ''}
            <div class="product-qty">${product.totalQty} ${product.uom}</div>
            ${lotInfo ? `<div class="product-lot">${lotInfo}</div>` : ''}
            ${statusInfo}
            <div class="product-last-count">üìÖ ${lastCountInfo}</div>
            ${product.lastCountUser ? `<div class="product-user">üë§ ${userInfo}</div>` : ''}
            ${diffInfo}
          </div>
        `;
      }).join('');
    }

    // Seleziona prodotto per modifica giacenza
    function selectProduct(productId) {
      const product = appState.products.find(p => p.id === productId);
      if (!product) return;

      // Se il prodotto ha pi√π di un lotto, mostra selezione lotti
      if (product.lots && product.lots.length > 1) {
        showLotSelection(product);
        return;
      }

      // Procedi con selezione normale se un solo lotto o nessun lotto
      appState.selectedProduct = product;

      // Rimuovi selezione precedente
      document.querySelectorAll('.product-card').forEach(card => {
        card.classList.remove('selected');
      });

      // Aggiungi selezione
      if (typeof event !== 'undefined' && event && event.currentTarget) {
        event.currentTarget.classList.add('selected');
      }

      showProductPanel(product);

      // Focus su quantit√† contata
      setTimeout(() => {
        document.getElementById('countedInput').focus();
      }, 100);
    }
    
    // Aggiorna indicatore differenza in tempo reale
    function updateDifferenceIndicator() {
      if (!appState.selectedProduct) return;
      
      const countedInputValue = document.getElementById('countedInput').value;
      const countedValue = parseFloat(countedInputValue);
      const indicator = document.getElementById('differenceIndicator');
      
      if (!indicator) return;
      
      if (isNaN(countedValue) || countedInputValue === '' || countedInputValue === null) {
        indicator.style.display = 'none';
        return;
      }
      
      const systemQty = appState.selectedLot ? appState.selectedLot.qty : appState.selectedProduct.totalQty;
      const difference = countedValue - systemQty;
      
      // Mostra l'indicatore
      indicator.style.display = 'flex';
      const diffValue = document.getElementById('differenceValue');
      const diffUom = document.getElementById('differenceUom');
      
      if (!diffValue || !diffUom) return;
      
      diffValue.textContent = (difference > 0 ? '+' : '') + difference.toFixed(2);
      diffUom.textContent = appState.selectedProduct.uom;
      
      // Colore basato su eccedenza/mancanza/uguale
      if (Math.abs(difference) < 0.001) {
        // Nessuna differenza
        indicator.style.background = 'rgba(16, 185, 129, 0.1)';
        const span = indicator.querySelector('span');
        if (span) span.style.color = 'var(--success)';
        diffValue.textContent = '0 (Conforme)';
      } else if (difference > 0) {
        // Eccedenza
        indicator.style.background = 'rgba(34, 197, 94, 0.1)';
        const span = indicator.querySelector('span');
        if (span) span.style.color = 'var(--success)';
        diffValue.textContent += ' (Eccedenza)';
      } else {
        // Mancanza
        indicator.style.background = 'rgba(239, 68, 68, 0.1)';
        const span = indicator.querySelector('span');
        if (span) span.style.color = 'var(--danger)';
        diffValue.textContent += ' (Mancanza)';
      }
    }

    // Setup campi lotto e scadenza nella scheda prodotto
    function setupLotFields(product) {
      // Reset campi
      document.getElementById('lotNumberInput').value = '';
      document.getElementById('expiryDateInput').value = '';
      appState.selectedLot = null;
      
      // Se il prodotto ha lotti esistenti, precompila il primo
      if (product.lots && product.lots.length > 0) {
        const firstLot = product.lots[0];
        document.getElementById('lotNumberInput').value = firstLot.name || '';
        
        // Precompila scadenza se esiste nel sistema
        if (firstLot.expiry_date) {
          // Formatta la data per il campo input date (YYYY-MM-DD)
          const expiryDate = new Date(firstLot.expiry_date);
          const formattedDate = expiryDate.toISOString().split('T')[0];
          document.getElementById('expiryDateInput').value = formattedDate;
        } else {
          document.getElementById('expiryDateInput').value = '';
        }
        
        // Crea lotto temporaneo
        appState.selectedLot = {
          id: firstLot.id,
          name: firstLot.name,
          qty: firstLot.qty,
          expiry_date: firstLot.expiry_date,
          isNew: false
        };
        
        // Aggiorna giacenza sistema per questo lotto
        document.getElementById('systemQuantity').textContent = firstLot.qty;
      } else {
        // Prodotto nuovo o senza lotti
        document.getElementById('systemQuantity').textContent = '0';
      }
      
      // Aggiungi listener per aggiornare il lotto in tempo reale
      const lotInput = document.getElementById('lotNumberInput');
      const expiryInput = document.getElementById('expiryDateInput');
      
      // Rimuovi listener precedenti (se esistenti)
      lotInput.removeEventListener('input', lotInput.updateLotHandler);
      lotInput.removeEventListener('blur', lotInput.updateLotHandler);
      expiryInput.removeEventListener('input', expiryInput.updateLotHandler);
      expiryInput.removeEventListener('change', expiryInput.updateLotHandler);
      
      // Crea e salva i gestori eventi
      lotInput.updateLotHandler = async function() { await updateLotFromFields(); };
      expiryInput.updateLotHandler = async function() { await updateLotFromFields(); };
      
      // Aggiungi nuovi listener
      lotInput.addEventListener('input', lotInput.updateLotHandler);
      lotInput.addEventListener('blur', lotInput.updateLotHandler);  // Quando esce dal campo
      // Solo 'change' per scadenza per evitare aggiornamenti continui che fanno sparire i pulsanti
      expiryInput.addEventListener('change', expiryInput.updateLotHandler);  // Quando cambia data
      
      // Focus sul primo campo vuoto
      setTimeout(() => {
        if (!lotInput.value) {
          lotInput.focus();
        } else if (!expiryInput.value) {
          expiryInput.focus();
        } else {
          document.getElementById('countedInput').focus();
        }
      }, 100);
    }
    
    // Aggiorna lotto quando l'utente modifica i campi
    async function updateLotFromFields() {
      const lotNumber = document.getElementById('lotNumberInput').value.trim();
      const expiryDate = document.getElementById('expiryDateInput').value;
      
      if (lotNumber) {
        // Verifica se √® un lotto esistente o nuovo
        let isExisting = false;
        let existingLot = null;
        
        if (appState.selectedProduct && appState.selectedProduct.lots) {
          existingLot = appState.selectedProduct.lots.find(lot => 
            lot.name === lotNumber && 
            (lot.expiry_date === expiryDate || (!lot.expiry_date && !expiryDate))
          );
          isExisting = !!existingLot;
        }
        
        if (isExisting) {
          // Lotto esistente
          appState.selectedLot = {
            id: existingLot.id,
            name: existingLot.name,
            qty: existingLot.qty,
            expiry_date: existingLot.expiry_date,
            isNew: false
          };
          document.getElementById('systemQuantity').textContent = existingLot.qty;
        } else {
          // Nuovo lotto - PER PRODOTTI NUOVI, CREA SUBITO IL QUANT
          appState.selectedLot = {
            id: null,
            name: lotNumber,
            qty: 0,
            expiry_date: expiryDate || null,
            isNew: true
          };
          document.getElementById('systemQuantity').textContent = '0';
          
          // Se √® un prodotto nuovo appena aggiunto, crea subito il quant base
          if (appState.selectedProduct && appState.selectedProduct.isNewProduct && lotNumber && expiryDate) {
            await createInitialQuantForNewProduct();
          }
        }
      } else {
        appState.selectedLot = null;
        document.getElementById('systemQuantity').textContent = '0';
      }
    }
    
    // Crea quant iniziale per prodotto nuovo
    async function createInitialQuantForNewProduct() {
      if (!appState.selectedProduct || !appState.selectedLot) return;
      
      try {
        console.log('Creando quant iniziale per prodotto nuovo...');
        
        // Prima crea il lotto se necessario
        let lotId = null;
        if (appState.selectedLot.name) {
          const lotData = {
            product_id: appState.selectedProduct.id,
            name: appState.selectedLot.name,
            company_id: 1
          };
          
          if (appState.selectedLot.expiry_date) {
            lotData.expiration_date = appState.selectedLot.expiry_date;
          }
          
          lotId = await rpc('stock.lot', 'create', [lotData]);
          appState.selectedLot.id = lotId;
          appState.selectedLot.isNew = false;
        }
        
        // Poi crea il quant con quantity = 0
        const quantData = {
          product_id: appState.selectedProduct.id,
          location_id: appState.currentLocation.id,
          quantity: 0,  // Giacenza sistema = 0
          lot_id: lotId || false
        };
        
        const quantId = await rpc('stock.quant', 'create', [quantData]);
        console.log('Quant iniziale creato:', quantId);
        
        // Ora il prodotto √® "registrato" nel sistema e dovrebbe funzionare il calcolo differenza
        appState.selectedProduct.isNewProduct = false;  // Non √® pi√π nuovo
        
        showNotification('‚úÖ Prodotto registrato nel sistema', 'success');
        
      } catch (error) {
        console.error('Errore creazione quant iniziale:', error);
        showNotification('Errore: ' + error.message, 'error');
      }
    }
    
    // Seleziona lotto specifico
    function selectLot(lot, index) {
      appState.selectedLot = lot;
      
      // Aggiorna UI
      document.querySelectorAll('.lot-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      document.querySelectorAll('.lot-option')[index].classList.add('selected');
      
      // Aggiorna giacenza sistema al lotto selezionato
      document.getElementById('systemQuantity').textContent = lot.qty;
      document.getElementById('selectedDetails').textContent = 
        `${appState.selectedProduct.code ? appState.selectedProduct.code + ' | ' : ''}Lotto: ${lot.name} | Giacenza: ${lot.qty} ${appState.selectedProduct.uom}`;
      
      // Reset campo contato e differenza
      document.getElementById('countedInput').value = '';
      document.getElementById('differenceIndicator').style.display = 'none';
    }

    // Conferma correzione inventario
    async function confirmQuantityChange() {
      if (!appState.selectedProduct) return;

      const countedQuantity = parseFloat(document.getElementById('countedInput').value);
      
      if (isNaN(countedQuantity) || countedQuantity < 0) {
        showNotification('Inserisci la quantit√† fisica contata (anche zero √® valido)', 'error');
        document.getElementById('countedInput').focus();
        return;
      }

      const product = appState.selectedProduct;
      
      // Validazione solo lotto obbligatorio (scadenza opzionale)
      const lotNumber = document.getElementById('lotNumberInput').value.trim();
      const expiryDate = document.getElementById('expiryDateInput').value;
      
      if (!lotNumber) {
        showNotification('Inserisci il numero lotto/serie (obbligatorio)', 'error');
        document.getElementById('lotNumberInput').focus();
        return;
      }
      
      // La scadenza √® opzionale - non serve validazione
      
      // Aggiorna il lotto con i valori attuali dai campi
      updateLotFromFields();
      
      // Se il lotto √® nuovo, dobbiamo crearlo in Odoo prima
      if (appState.selectedLot.isNew) {
        try {
          // Prima verifica se il lotto esiste gi√† nel sistema
          const existingLots = await searchRead(
            'stock.lot',
            [
              ['product_id', '=', product.id],
              ['name', '=', appState.selectedLot.name]
            ],
            ['id', 'expiration_date'],
            1
          );
          
          if (existingLots && existingLots.length > 0) {
            // Lotto gi√† esistente, usa quello
            const existingLot = existingLots[0];
            appState.selectedLot.id = existingLot.id;
            appState.selectedLot.isNew = false;
            
            // Se le scadenze sono diverse, usa sempre quella inserita dall'utente
            if (existingLot.expiration_date !== appState.selectedLot.expiry_date) {
              // Aggiorna automaticamente la scadenza del lotto esistente con quella inserita
              try {
                await rpc('stock.lot', 'write', [
                  [existingLot.id],
                  { expiration_date: appState.selectedLot.expiry_date }
                ]);
                console.log('Scadenza lotto aggiornata automaticamente');
                showNotification('‚úÖ Scadenza lotto aggiornata', 'success');
              } catch (updateError) {
                console.error('Errore aggiornamento scadenza:', updateError);
                // Se non riesce ad aggiornare, usa la scadenza esistente
                appState.selectedLot.expiry_date = existingLot.expiration_date;
                document.getElementById('expiryDateInput').value = existingLot.expiration_date ? 
                  new Date(existingLot.expiration_date).toISOString().split('T')[0] : '';
              }
            }
            
            console.log('Usando lotto esistente:', existingLot.id);
            
          } else {
            // Crea nuovo lotto
            const lotData = {
              product_id: product.id,
              name: appState.selectedLot.name,
              company_id: 1
            };
            
            if (appState.selectedLot.expiry_date) {
              lotData.expiration_date = appState.selectedLot.expiry_date;
            }
            
            const newLotId = await rpc('stock.lot', 'create', [lotData]);
            console.log('Nuovo lotto creato in Odoo:', newLotId);
            
            // Aggiorna il lotto con l'ID reale
            appState.selectedLot.id = newLotId;
            appState.selectedLot.isNew = false;
          }
          
        } catch (lotError) {
          console.error('Errore gestione lotto:', lotError);
          if (lotError.message.includes('already exists')) {
            showNotification('Il lotto esiste gi√† nel sistema. Ricarica la pagina e riprova.', 'error');
          } else {
            showNotification('Errore nella gestione del lotto: ' + lotError.message, 'error');
          }
          return;
        }
      }
      
      // Confronta quantit√† sistema vs contata
      const systemQty = appState.selectedLot ? appState.selectedLot.qty : product.totalQty;
      const difference = countedQuantity - systemQty;

      if (Math.abs(difference) < 0.001) {
        showNotification('‚úÖ Quantit√† confermata - nessuna differenza', 'success');
        cancelSelection();
        return;
      }

      try {
        showLoading();

        // Usa l'utente salvato nello stato o recuperalo se necessario
        let currentUser = appState.currentUser;
        if (!currentUser) {
          console.log('üîÑ Recupero utente corrente...');
          currentUser = await getCurrentUser();
          appState.currentUser = currentUser; // Salva per prossimo uso
        }
        
        console.log('üë§ Salvando conteggio con utente:', currentUser);
        
        // Aggiorna inventory_quantity su stock.quant con utente
        const result = await updateInventoryQuantity({
          product_id: product.id,
          product_name: product.name,
          location_id: appState.currentLocation.id,
          location_name: appState.currentLocation.name,
          system_qty: systemQty,
          counted_qty: countedQuantity,
          difference: difference,
          lot_id: appState.selectedLot ? appState.selectedLot.id : null,
          lot_name: appState.selectedLot ? appState.selectedLot.name : null,
          user_id: currentUser ? currentUser.id : 1,
          user_name: currentUser ? currentUser.name : 'Utente sconosciuto'
        });

        if (result.success) {
          const lotInfo = appState.selectedLot ? ` (Lotto: ${appState.selectedLot.name})` : '';
          const diffIcon = difference > 0 ? 'üìà' : 'üìâ';
          showNotification(
            `üìù Conteggio salvato: Sistema ${systemQty} ‚Üí Contato ${countedQuantity}${lotInfo} (In attesa convalida)`, 
            'info'
          );

          // Reset e ricarica
          cancelSelection();
          await loadLocationProducts(appState.currentLocation.id);
          
          // Riporta focus sul campo ubicazione dopo il conteggio
          setTimeout(() => {
            document.getElementById('locationScanner').focus();
          }, 500);
        } else {
          throw new Error(result.error || 'Errore nell\'aggiornamento');
        }

      } catch (error) {
        console.error('Errore correzione inventario:', error);
        showNotification('Errore: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }

    // Aggiorna inventory_quantity su stock.quant (Odoo 17)
    async function updateInventoryQuantity(data) {
      try {
        console.log('Aggiornamento inventory_quantity:', data);
        
        // Trova il quant specifico per prodotto, ubicazione e lotto
        let domain = [
          ['product_id', '=', data.product_id],
          ['location_id', '=', data.location_id]
        ];
        
        if (data.lot_id) {
          domain.push(['lot_id', '=', data.lot_id]);
        } else {
          domain.push(['lot_id', '=', false]);
        }
        
        const quants = await searchRead(
          'stock.quant',
          domain,
          ['id', 'quantity', 'inventory_quantity'],
          false
        );
        
        console.log('Quants trovati:', quants);
        
        if (!quants || quants.length === 0) {
          // Nessun quant esistente - ne creiamo uno nuovo
          console.log('Nessun quant esistente, creo nuovo quant per prodotto:', data.product_id, 'ubicazione:', data.location_id, 'lotto:', data.lot_id);
          
          const newQuantData = {
            product_id: data.product_id,
            location_id: data.location_id,
            quantity: 0,  // Inizia a 0
            inventory_quantity: data.counted_qty,  // Quantit√† contata
            lot_id: data.lot_id || false
          };
          
          try {
            const newQuantId = await rpc('stock.quant', 'create', [newQuantData]);
            console.log('Nuovo quant creato:', newQuantId, 'con inventory_quantity:', data.counted_qty);
            
            // Aggiungi messaggio per nuovo quant
            try {
              const messageBody = `
                <div style="font-family: Arial, sans-serif;">
                  <h3 style="color: #10b981;">üì¶ Nuovo Quant Creato</h3>
                  <hr style="border: 1px solid #e5e7eb; margin: 10px 0;">
                  
                  <p><strong>üè∑Ô∏è Prodotto:</strong> ${data.product_name}</p>
                  <p><strong>üìç Ubicazione:</strong> ${data.location_name}</p>
                  <p><strong>üìä Quantit√† contata:</strong> ${data.counted_qty}</p>
                  ${data.lot_name ? `<p><strong>üì¶ Lotto/Serie:</strong> ${data.lot_name}</p>` : ''}
                  <p><strong>üìÖ Data/Ora:</strong> ${new Date().toLocaleString('it-IT')}</p>
                  
                  <hr style="border: 1px solid #e5e7eb; margin: 10px 0;">
                  <p style="color: #6b7280; font-size: 12px;">
                    <em>Nuovo prodotto aggiunto da app Gestione Ubicazioni</em><br>
                    <em>Quant creato con inventory_quantity - In attesa di convalida</em>
                  </p>
                </div>
              `;

              await rpc('mail.message', 'create', [{
                model: 'product.product',
                res_id: data.product_id,
                body: messageBody,
                message_type: 'comment',
                subtype_id: 1
              }]);
            } catch (msgError) {
              console.error('Errore aggiunta messaggio nuovo quant:', msgError);
            }
            
            return { 
              success: true, 
              quant_ids: [newQuantId],
              results: [{ quant_id: newQuantId, created: true }]
            };
            
          } catch (createError) {
            console.error('Errore creazione nuovo quant:', createError);
            throw new Error('Impossibile creare il quant per questo prodotto/ubicazione: ' + createError.message);
          }
        }
        
        // Aggiorna inventory_quantity per ogni quant trovato
        const results = [];
        for (const quant of quants) {
          const updateData = {
            inventory_quantity: data.counted_qty,
            inventory_date: new Date().toISOString().split('T')[0] + ' ' + new Date().toTimeString().split(' ')[0]
          };
          
          // Aggiungi user_id se disponibile
          if (data.user_id) {
            updateData.user_id = data.user_id;
          }
          
          const updateResult = await rpc('stock.quant', 'write', [
            [quant.id],
            updateData
          ]);
          
          console.log(`Quant ${quant.id} aggiornato - inventory_quantity: ${data.counted_qty}`);
          results.push({ quant_id: quant.id, updated: updateResult });
        }
        
        // NON applichiamo le correzioni automaticamente
        // Il responsabile convalider√† dall'interfaccia Odoo
        const quantIds = quants.map(q => q.id);
        console.log('Inventory_quantity aggiornato per quants:', quantIds, '- In attesa di convalida manuale');
        
        // Aggiungi nota nel chatter del prodotto
        try {
          const messageBody = `
            <div style="font-family: Arial, sans-serif;">
              <h3 style="color: #10b981;">üìù Correzione Inventario</h3>
              <hr style="border: 1px solid #e5e7eb; margin: 10px 0;">
              
              <p><strong>üè∑Ô∏è Prodotto:</strong> ${data.product_name}</p>
              <p><strong>üìç Ubicazione:</strong> ${data.location_name}</p>
              <p><strong>üíª Giacenza sistema:</strong> ${data.system_qty}</p>
              <p><strong>üìä Quantit√† contata:</strong> ${data.counted_qty}</p>
              <p><strong>üìà Differenza:</strong> ${data.difference > 0 ? '+' : ''}${data.difference} ${data.difference > 0 ? '(Eccedenza)' : data.difference < 0 ? '(Mancanza)' : ''}</p>
              ${data.lot_name ? `<p><strong>üì¶ Lotto/Serie:</strong> ${data.lot_name}</p>` : ''}
              <p><strong>üìÖ Data/Ora:</strong> ${new Date().toLocaleString('it-IT')}</p>
              
              <hr style="border: 1px solid #e5e7eb; margin: 10px 0;">
              <p style="color: #6b7280; font-size: 12px;">
                <em>Conteggio inventario da app Gestione Ubicazioni</em><br>
                <em>Campo inventory_quantity aggiornato - In attesa di convalida</em>
              </p>
            </div>
          `;

          // Prova ad aggiungere il messaggio al prodotto
          await rpc('mail.message', 'create', [{
            model: 'product.product',
            res_id: data.product_id,
            body: messageBody,
            message_type: 'comment',
            subtype_id: 1
          }]);
        } catch (msgError) {
          console.error('Errore aggiunta messaggio al prodotto:', msgError);
        }
        
        return { 
          success: true, 
          quant_ids: quantIds,
          results: results
        };

      } catch (error) {
        console.error('Errore aggiornamento inventory_quantity:', error);
        return { success: false, error: error.message };
      }
    }


    // Annulla selezione
    function cancelSelection() {
      appState.selectedProduct = null;
      appState.selectedLot = null;
      
      const bottomPanel = document.getElementById('bottomPanel');
      if (bottomPanel) {
        bottomPanel.classList.remove('active');
        // Rimuovi padding dal main container
        document.querySelector('.main-container').classList.remove('panel-open');
      }
      
      const lotSelector = document.getElementById('lotSelector');
      if (lotSelector) {
        lotSelector.style.display = 'none';
      }
      
      const differenceIndicator = document.getElementById('differenceIndicator');
      if (differenceIndicator) {
        differenceIndicator.style.display = 'none';
      }
      
      document.querySelectorAll('.product-card').forEach(card => {
        card.classList.remove('selected');
      });
      
      // Riporta focus sul campo ubicazione dopo l'annullamento
      setTimeout(() => {
        document.getElementById('locationScanner').focus();
      }, 100);
    }

    // Scanner fotocamera
    function openLocationScanner() {
      appState.scannerMode = 'location';
      document.getElementById('scannerTitle').textContent = 'üì∑ Scansiona Ubicazione';
      document.getElementById('scannerModal').classList.add('active');
      
      if (!appState.scanner) {
        appState.scanner = new Html5Qrcode("reader");
      }

      const config = { 
        fps: 10, 
        qrbox: { width: 250, height: 250 } 
      };

      appState.scanner.start(
        { facingMode: "environment" },
        config,
        (decodedText) => {
          closeScanner();
          scanLocation(decodedText);
        },
        (errorMessage) => {
          // Ignora errori di scansione continui
        }
      ).catch((err) => {
        console.error('Errore avvio scanner:', err);
        showNotification('Errore nell\'avvio della fotocamera', 'error');
      });

      appState.scannerActive = true;
    }

    function closeScanner() {
      if (appState.scanner && appState.scannerActive) {
        appState.scanner.stop();
        appState.scannerActive = false;
      }
      document.getElementById('scannerModal').classList.remove('active');
    }

    function useManualCode() {
      const code = document.getElementById('manualCode').value.trim();
      if (code) {
        if (appState.scannerMode === 'location') {
          closeScanner();
          scanLocation(code);
        }
        document.getElementById('manualCode').value = '';
      }
    }

    // Ricerca prodotti da aggiungere
    function openProductSearch() {
      if (!appState.currentLocation) {
        showNotification('Prima scansiona un\'ubicazione', 'error');
        return;
      }
      
      document.getElementById('searchPanel').classList.add('active');
      document.getElementById('currentLocationName').textContent = appState.currentLocation.name;
      document.getElementById('searchInput').value = '';
      document.getElementById('searchResults').innerHTML = `
        <div style="text-align: center; color: var(--muted); padding: 20px;">
          Inserisci almeno 3 caratteri per iniziare la ricerca
        </div>
      `;
      setTimeout(() => {
        document.getElementById('searchInput').focus();
      }, 100);
    }
    
    function closeProductSearch() {
      document.getElementById('searchPanel').classList.remove('active');
      
      // Riporta focus sul campo ubicazione dopo la chiusura ricerca
      setTimeout(() => {
        document.getElementById('locationScanner').focus();
      }, 100);
    }

    // La ricerca ora √® sempre in tutto il magazzino per aggiungere prodotti

    let searchTimeout;
    async function searchProducts() {
      const searchTerm = document.getElementById('searchInput').value.trim();
      
      if (searchTerm.length < 3) {
        document.getElementById('searchResults').innerHTML = `
          <div style="text-align: center; color: var(--muted); padding: 20px;">
            Inserisci almeno 3 caratteri per iniziare la ricerca
          </div>
        `;
        return;
      }

      document.getElementById('searchResults').innerHTML = `
        <div style="text-align: center; color: var(--accent); padding: 20px;">
          ‚è≥ Ricerca in corso...
        </div>
      `;

      try {
        // Ricerca sempre in tutto il magazzino
        const products = await searchRead(
          'product.product',
          [
            '|', '|',
            ['name', 'ilike', searchTerm],
            ['default_code', 'ilike', searchTerm],
            ['barcode', 'ilike', searchTerm]
          ],
          ['id', 'name', 'default_code', 'barcode', 'image_128', 'tracking'],
          30
        );

        renderSearchResults(products);

      } catch (error) {
        console.error('Errore ricerca prodotti:', error);
        document.getElementById('searchResults').innerHTML = `
          <div style="text-align: center; color: var(--danger); padding: 20px;">
            ‚ùå Errore nella ricerca: ${error.message}
          </div>
        `;
      }
    }

    function renderSearchResults(products) {
      const resultsDiv = document.getElementById('searchResults');

      if (!products || products.length === 0) {
        resultsDiv.innerHTML = `
          <div style="text-align: center; color: var(--danger); padding: 20px;">
            ‚ùå Nessun prodotto trovato
          </div>
        `;
        return;
      }

      resultsDiv.innerHTML = '';
      products.forEach(product => {
        const productDiv = document.createElement('div');
        productDiv.className = 'search-result-item';

        const imgHtml = product.image_128 
          ? `<img src="data:image/png;base64,${product.image_128}" class="search-result-image">`
          : '<div class="search-result-image" style="display:flex;align-items:center;justify-content:center;font-size:20px;">üì¶</div>';

        productDiv.innerHTML = `
          ${imgHtml}
          <div class="search-result-info">
            <div class="search-result-name">${product.name}</div>
            <div class="search-result-details">
              ${product.default_code ? `Codice: ${product.default_code}` : ''}
              ${product.barcode ? ` | Barcode: ${product.barcode}` : ''}
            </div>
          </div>
        `;

        productDiv.onclick = () => {
          // Previene doppi click
          if (productDiv.disabled) return;
          productDiv.disabled = true;
          productDiv.style.opacity = '0.6';
          selectSearchResult(product).finally(() => {
            productDiv.disabled = false;
            productDiv.style.opacity = '1';
          });
        };
        resultsDiv.appendChild(productDiv);
      });
    }

    async function selectSearchResult(product) {
      // Proponiamo sempre trasferimento del prodotto nell'ubicazione corrente
      await showTransferToCurrentLocation(product);
    }

    // Trasferimento nell'ubicazione corrente
    async function showTransferToCurrentLocation(product) {
      try {
        showLoading();

        // Cerca disponibilit√† nel buffer e in altre ubicazioni
        const availableQuants = await searchRead(
          'stock.quant',
          [
            ['product_id', '=', product.id],
            ['quantity', '>', 0],
            ['location_id.usage', '=', 'internal'],  // Solo ubicazioni interne
            ['location_id', '!=', appState.currentLocation.id]  // Escludi ubicazione corrente
          ],
          ['location_id', 'quantity', 'lot_id'],
          false
        );

        if (!availableQuants || availableQuants.length === 0) {
          // Prodotto non trovato - lo aggiungiamo come giacenza 0 per conteggio
          await addProductWithZeroStock(product);
          return;
        }

        // Calcola totale disponibile
        const totalAvailable = availableQuants.reduce((sum, q) => sum + q.quantity, 0);
        
        // Mostra sezione trasferimento
        appState.transferProduct = { 
          ...product, 
          availableQty: totalAvailable,
          sourceQuants: availableQuants
        };
        
        document.getElementById('transferSection').classList.add('active');
        document.getElementById('transferProductName').textContent = product.name;
        document.getElementById('transferBufferQty').textContent = `${totalAvailable} PZ disponibili`;
        document.getElementById('transferDestLocation').textContent = appState.currentLocation.name;
        document.getElementById('transferQty').value = '';
        document.getElementById('transferLotNumber').value = '';
        document.getElementById('transferExpiryDate').value = '';
        
        // Chiudi pannello ricerca
        closeProductSearch();
        
        showNotification(`‚úÖ Prodotto disponibile: ${totalAvailable} PZ da trasferire`, 'success');

      } catch (error) {
        showNotification('Errore: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }
    
    // Aggiungi prodotto con giacenza 0 per conteggio fisico
    async function addProductWithZeroStock(product) {
      try {
        // Aggiungi prodotto alla lista locale con giacenza 0
        const newProduct = {
          id: product.id,
          name: product.name,
          code: product.default_code || product.barcode || '',
          image: product.image_128 ? `data:image/png;base64,${product.image_128}` : null,
          uom: 'PZ',
          uom_id: null,
          totalQty: 0,
          tracking: product.tracking || 'none',
          lots: [],
          isNewProduct: true  // Flag per identificare prodotti aggiunti
        };
        
        // Verifica se gi√† presente
        const existingIndex = appState.products.findIndex(p => p.id === product.id);
        if (existingIndex >= 0) {
          showNotification('Prodotto gi√† presente nell\'ubicazione', 'info');
          closeProductSearch();
          return;
        }
        
        appState.products.push(newProduct);
        renderProducts();
        
        closeProductSearch();
        showNotification(`‚úÖ Prodotto aggiunto per conteggio: ${product.name}`, 'success');
        
        // Auto-seleziona per conteggio immediato
        setTimeout(() => {
          selectProduct(product.id);
          console.log('Prodotto nuovo selezionato automaticamente per conteggio');
        }, 500);
        
      } catch (error) {
        showNotification('Errore: ' + error.message, 'error');
      }
    }

    async function executeTransferFromBuffer() {
      if (!appState.transferProduct || !appState.currentLocation) return;

      const quantity = parseFloat(document.getElementById('transferQty').value);
      const lotNumber = document.getElementById('transferLotNumber').value.trim();
      const expiryDate = document.getElementById('transferExpiryDate').value;

      if (isNaN(quantity) || quantity < 0) {
        showNotification('Inserisci una quantit√† valida (anche zero)', 'error');
        document.getElementById('transferQty').focus();
        return;
      }
      
      if (!lotNumber) {
        showNotification('Inserisci il numero lotto/serie', 'error');
        document.getElementById('transferLotNumber').focus();
        return;
      }
      
      if (!expiryDate) {
        showNotification('Inserisci la data di scadenza', 'error');
        document.getElementById('transferExpiryDate').focus();
        return;
      }

      // RIMOSSO: Non controlliamo pi√π il limite disponibilit√†
      // Si pu√≤ trasferire qualsiasi quantit√†, anche se va in negativo

      try {
        showLoading();

        const result = await createTransferFromBuffer({
          product_id: appState.transferProduct.id,
          product_name: appState.transferProduct.name,
          quantity: quantity,
          dest_location_id: appState.currentLocation.id,
          dest_location_name: appState.currentLocation.name,
          lot_number: lotNumber,
          expiry_date: expiryDate
        });

        if (result.success) {
          showNotification(
            `‚úÖ Trasferito ${quantity} PZ (Lotto: ${lotNumber}) a ${appState.currentLocation.name}`, 
            'success'
          );

          cancelTransfer();
          await loadLocationProducts(appState.currentLocation.id);
          
          // Riporta focus sul campo ubicazione dopo il trasferimento
          setTimeout(() => {
            document.getElementById('locationScanner').focus();
          }, 500);
        } else {
          throw new Error(result.error || 'Errore nel trasferimento');
        }

      } catch (error) {
        console.error('Errore trasferimento:', error);
        showNotification('Errore: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }

    async function createTransferFromBuffer(data) {
      try {
        // Trova picking type interno
        const pickingTypes = await searchRead(
          'stock.picking.type',
          [['code', '=', 'internal']],
          ['id'],
          1
        );

        if (!pickingTypes || pickingTypes.length === 0) {
          throw new Error('Picking type interno non trovato');
        }

        // Crea picking
        const pickingData = {
          picking_type_id: pickingTypes[0].id,
          location_id: CONFIG.bufferLocation.id,
          location_dest_id: data.dest_location_id,
          origin: `WEB-BUFFER-${Date.now()}`,
          state: 'draft'
        };

        const pickingId = await rpc('stock.picking', 'create', [pickingData]);

        // Crea movimento
        const moveData = {
          picking_id: pickingId,
          product_id: data.product_id,
          name: `Transfer ${data.product_name} from Buffer`,
          product_uom_qty: data.quantity,
          location_id: CONFIG.bufferLocation.id,
          location_dest_id: data.dest_location_id,
          state: 'draft'
        };

        const moveId = await rpc('stock.move', 'create', [moveData]);

        // Conferma picking
        await rpc('stock.picking', 'action_confirm', [[pickingId]]);

        // Crea move line con lotto obbligatorio
        const moveLineData = {
          move_id: moveId,
          picking_id: pickingId,
          product_id: data.product_id,
          qty_done: data.quantity,
          location_id: CONFIG.bufferLocation.id,
          location_dest_id: data.dest_location_id
        };
        
        // Crea o trova il lotto
        if (data.lot_number) {
          try {
            // Cerca se il lotto esiste gi√†
            const existingLots = await searchRead(
              'stock.lot',
              [
                ['product_id', '=', data.product_id],
                ['name', '=', data.lot_number]
              ],
              ['id', 'expiration_date'],
              1
            );
            
            let lotId;
            if (existingLots && existingLots.length > 0) {
              // Usa lotto esistente
              lotId = existingLots[0].id;
            } else {
              // Crea nuovo lotto
              const lotData = {
                product_id: data.product_id,
                name: data.lot_number,
                company_id: 1  // Assumendo company ID 1
              };
              
              if (data.expiry_date) {
                lotData.expiration_date = data.expiry_date;
              }
              
              lotId = await rpc('stock.lot', 'create', [lotData]);
            }
            
            moveLineData.lot_id = lotId;
            
          } catch (lotError) {
            console.error('Errore gestione lotto:', lotError);
            // Continua senza lotto se c'√® errore
          }
        }

        await rpc('stock.move.line', 'create', [moveLineData]);

        // Valida picking
        const validationResult = await rpc('stock.picking', 'button_validate', [[pickingId]]);
        
        if (validationResult && validationResult.res_model) {
          if (validationResult.res_model === 'stock.immediate.transfer') {
            await rpc('stock.immediate.transfer', 'process', [[validationResult.res_id]]);
          }
        }

        return { success: true, picking_id: pickingId };

      } catch (error) {
        console.error('Errore creazione trasferimento:', error);
        return { success: false, error: error.message };
      }
    }

    function cancelTransfer() {
      appState.transferProduct = null;
      document.getElementById('transferSection').classList.remove('active');
      
      // Riporta focus sul campo ubicazione dopo l'annullamento trasferimento
      setTimeout(() => {
        document.getElementById('locationScanner').focus();
      }, 100);
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üéØ DOMContentLoaded - Inizializzo event listeners');

      // Scanner ubicazione con Enter e pistola
      const locationInput = document.getElementById('locationScanner');
      console.log('üéØ Input ubicazione trovato:', locationInput);

      if (!locationInput) {
        console.error('‚ùå ERRORE: Input locationScanner non trovato!');
        return;
      }

      locationInput.addEventListener('keypress', (e) => {
        console.log('‚å®Ô∏è Tasto premuto:', e.key);
        if (e.key === 'Enter') {
          const code = locationInput.value.trim();
          console.log('‚å®Ô∏è ENTER premuto, codice:', code);
          if (code) {
            console.log('üöÄ Chiamo scanLocation con:', code);
            scanLocation(code);
          }
        }
      });

      // Auto-submit per pistola scanner (timeout dopo ultima digitazione)
      let scannerTimeout;
      locationInput.addEventListener('input', (e) => {
        clearTimeout(scannerTimeout);
        scannerTimeout = setTimeout(() => {
          const code = locationInput.value.trim();
          if (code && code.length >= 3) {
            scanLocation(code);
          }
        }, 800); // Aumentato timeout per tablet
      });

      // Setup ricerca prodotti
      const searchInput = document.getElementById('searchInput');
      searchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(searchProducts, 500); // Aumentato timeout per tablet
      });

      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          clearTimeout(searchTimeout);
          searchProducts();
        }
      });
      
      // Setup Enter per conferma rapida
      const countedInput = document.getElementById('countedInput');
      countedInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          confirmQuantityChange();
        }
      });

      // Click su ricerca per aprire pannello
      searchInput.addEventListener('focus', () => {
        document.getElementById('searchPanel').classList.add('active');
      });

      // Gestione tasti
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const calculatorModal = document.getElementById('calculatorModal');
          if (calculatorModal && calculatorModal.style.display === 'flex') {
            closeCalculator();
          } else if (appState.scannerActive) {
            closeScanner();
          } else if (appState.selectedProduct) {
            cancelSelection();
          } else if (appState.transferProduct) {
            cancelTransfer();
          } else {
            closeProductSearch();
          }
        }
      });

      // Focus intelligente - solo quando utile per scanner
      window.focusLocationField = function() {
        locationInput.focus();
      };
      
      // Focus automatico solo dopo operazioni che lo richiedono
      locationInput.addEventListener('blur', () => {
        // Non rifocalizzare automaticamente per evitare interferenze con altri campi
      });
    });

    // Verifica connessione
    async function checkConnection() {
      const statusEl = document.getElementById('connectionStatus');
      const statusText = document.getElementById('statusText');

      const token = csrf();
      if (!token) {
        statusEl.className = 'connection-status disconnected';
        statusText.textContent = 'Non autenticato';
        return false;
      }

      try {
        const test = await searchRead('product.product', [], ['id'], 1);
        if (test) {
          statusEl.className = 'connection-status connected';
          statusText.textContent = 'Connesso';
          return true;
        }
      } catch (error) {
        console.error('Errore connessione:', error);
      }

      statusEl.className = 'connection-status disconnected';
      statusText.textContent = 'Non connesso';
      return false;
    }

    // Utilities
    function showLoading() {
      document.getElementById('loadingOverlay').style.display = 'flex';
    }

    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // Variabili calcolatrice
    let currentCalcInput = '0';
    let shouldResetCalcDisplay = false;
    let originalQtyValue = '';
    let currentCalcTargetField = 'countedInput'; // Campo target attuale
    
    // Funzioni Calcolatrice
    function openCalculator() {
      currentCalcTargetField = 'countedInput';
      originalQtyValue = document.getElementById('countedInput').value || '0';
      currentCalcInput = originalQtyValue;
      
      // Mostra l'unit√† di misura nel titolo della calcolatrice
      const uom = appState.selectedProduct?.uom || document.getElementById('uomLabel').textContent || 'PZ';
      document.getElementById('calculatorTitle').textContent = `üî¢ Calcolatrice (${uom})`;
      
      document.getElementById('calculatorModal').style.display = 'flex';
      updateCalcDisplay();
      
      showNotification('üî¢ Calcolatrice aperta', 'info');
    }
    
    function openTransferCalculator() {
      currentCalcTargetField = 'transferQty';
      originalQtyValue = document.getElementById('transferQty').value || '0';
      currentCalcInput = originalQtyValue;
      
      // Mostra l'unit√† di misura nel titolo della calcolatrice  
      const uom = appState.transferProduct?.uom || 'PZ';
      document.getElementById('calculatorTitle').textContent = `üî¢ Calcolatrice (${uom})`;
      
      document.getElementById('calculatorModal').style.display = 'flex';
      updateCalcDisplay();
      
      showNotification('üî¢ Calcolatrice aperta', 'info');
    }

    function closeCalculator() {
      document.getElementById('calculatorModal').style.display = 'none';
      // Riporta focus sul campo corretto dopo chiusura calcolatrice
      setTimeout(() => {
        const targetField = document.getElementById(currentCalcTargetField);
        if (targetField) {
          targetField.removeAttribute('readonly');
          targetField.focus();
          targetField.setAttribute('readonly', true);
        }
      }, 100);
    }

    function updateCalcDisplay() {
      document.getElementById('calcDisplay').textContent = currentCalcInput;
    }

    function clearCalc() {
      currentCalcInput = '0';
      shouldResetCalcDisplay = false;
      updateCalcDisplay();
    }

    function appendToCalc(value) {
      if (shouldResetCalcDisplay) {
        if (!'+-*/'.includes(value)) {
          currentCalcInput = value;
          shouldResetCalcDisplay = false;
        } else {
          currentCalcInput += value;
          shouldResetCalcDisplay = false;
        }
      } else {
        if (currentCalcInput === '0' && value !== '.') {
          currentCalcInput = value;
        } else {
          currentCalcInput += value;
        }
      }
      updateCalcDisplay();
    }

    function deleteLastCalc() {
      if (currentCalcInput.length > 1) {
        currentCalcInput = currentCalcInput.slice(0, -1);
      } else {
        currentCalcInput = '0';
      }
      updateCalcDisplay();
    }

    function calculateResult() {
      try {
        let expression = currentCalcInput.replace(/√ó/g, '*').replace(/√∑/g, '/');
        let result = eval(expression);
        
        if (result % 1 !== 0) {
          result = parseFloat(result.toFixed(2));
        }
        
        currentCalcInput = result.toString();
        shouldResetCalcDisplay = true;
        updateCalcDisplay();
      } catch (error) {
        currentCalcInput = 'Errore';
        shouldResetCalcDisplay = true;
        updateCalcDisplay();
      }
    }

    function confirmCalculation() {
      const result = parseFloat(currentCalcInput);
      
      if (!isNaN(result) && result >= 0) {
        document.getElementById(currentCalcTargetField).value = result;
        
        // Aggiorna indicatore differenza solo per il campo conteggio
        if (currentCalcTargetField === 'countedInput') {
          updateDifferenceIndicator();
        }
        
        closeCalculator();
        showNotification(`Quantit√† impostata: ${result}`, 'success');
      } else {
        showNotification('Inserisci una quantit√† valida (anche zero)', 'error');
      }
    }
    
    // Ottieni utente corrente - VERSIONE CORRETTA
    async function getCurrentUser() {
      try {
        console.log('üîç Cercando utente loggato corrente...');
        
        // METODO CORRETTO: usa il csrf token per ottenere la sessione
        const response = await fetch('/web/session/get_session_info', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrf()
          },
          credentials: 'include',
          body: JSON.stringify({})
        });
        
        const sessionData = await response.json();
        console.log('üìã Dati sessione completi:', sessionData);
        
        if (sessionData && sessionData.uid) {
          // Ottieni dettagli completi dell'utente
          const userDetails = await rpc('res.users', 'read', [
            [sessionData.uid], 
            ['id', 'name', 'login', 'email']
          ]);
          
          if (userDetails && userDetails.length > 0) {
            const user = userDetails[0];
            console.log('‚úÖ Utente trovato:', user);
            return {
              id: user.id,
              name: user.name,
              login: user.login,
              email: user.email || ''
            };
          }
        }
      } catch (error) {
        console.error('‚ùå Errore recupero sessione:', error);
      }
      
      try {
        // FALLBACK: prova con chiamata RPC diretta 
        const result = await rpc('res.users', 'get_current_user', []);
        if (result) {
          console.log('‚úÖ Utente da get_current_user:', result);
          return result;
        }
      } catch (error) {
        console.error('‚ùå Errore get_current_user:', error);
      }
      
      try {
        // FALLBACK 2: usa context dell'utente corrente
        const userContext = await rpc('res.users', 'context_get', []);
        console.log('üìã Context utente:', userContext);
        
        if (userContext && userContext.uid) {
          const user = await rpc('res.users', 'read', [
            [userContext.uid], 
            ['id', 'name', 'login']
          ]);
          if (user && user.length > 0) {
            console.log('‚úÖ Utente da context:', user[0]);
            return user[0];
          }
        }
      } catch (error) {
        console.error('‚ùå Errore context utente:', error);
      }
      
      // ULTIMO FALLBACK: almeno prova a ottenere l'UID dalla sessione web
      try {
        if (window.odoo && window.odoo.session_info && window.odoo.session_info.uid) {
          const uid = window.odoo.session_info.uid;
          const user = await rpc('res.users', 'read', [[uid], ['id', 'name', 'login']]);
          if (user && user.length > 0) {
            console.log('‚úÖ Utente da window.odoo:', user[0]);
            return user[0];
          }
        }
      } catch (error) {
        console.error('‚ùå Errore window.odoo:', error);
      }
      
      console.log('‚ö†Ô∏è Usando fallback Admin');
      return { id: 1, name: 'Admin', login: 'admin' };
    }
    
    // Gestione selezione lotti
    function showLotSelection(product) {
      document.getElementById('productNameForLots').textContent = `${product.name} (${product.code || ''})`;
      
      const lotsList = document.getElementById('lotsList');
      lotsList.innerHTML = product.lots.map((lot, index) => {
        const isCountedRecent = lot.lastCountDate && isWithinDays(lot.lastCountDate, 5);
        const statusClass = isCountedRecent ? 'counted-recent' : '';
        const statusText = isCountedRecent ? 
          `üïê Contato ${Math.ceil((new Date() - new Date(lot.lastCountDate)) / (1000 * 60 * 60 * 24))}g fa` :
          (lot.lastCountDate ? '‚úì Contato (vecchio)' : '‚è≥ Da contare');
        
        return `
          <div onclick="selectSpecificLot(${product.id}, ${index})" 
               style="background: var(--card-hover); border: 1px solid var(--border); border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease;"
               onmouseover="this.style.borderColor='var(--accent)'"
               onmouseout="this.style.borderColor='var(--border)'">
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="font-weight: 600; color: var(--text);">üè∑Ô∏è ${lot.name}</div>
              <div style="font-weight: 700; color: var(--accent);">${lot.qty} ${product.uom}</div>
            </div>
            
            <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">
              ${lot.expiry_date ? `üìÖ Scad: ${new Date(lot.expiry_date).toLocaleDateString('it-IT')}` : 'Nessuna scadenza'}
            </div>
            
            <div style="font-size: 11px; color: var(--info);">${statusText}</div>
            
            ${lot.lastCountUser ? `<div style="font-size: 10px; color: var(--accent); margin-top: 2px;">üë§ ${lot.lastCountUser}</div>` : ''}
          </div>
        `;
      }).join('');
      
      document.getElementById('lotSelectionModal').style.display = 'flex';
    }
    
    function closeLotSelection() {
      document.getElementById('lotSelectionModal').style.display = 'none';
    }
    
    function selectSpecificLot(productId, lotIndex) {
      const product = appState.products.find(p => p.id === productId);
      if (!product || !product.lots[lotIndex]) return;
      
      const selectedLot = product.lots[lotIndex];
      
      // Crea un prodotto "virtuale" per questo specifico lotto
      const lotProduct = {
        ...product,
        selectedLotIndex: lotIndex,
        totalQty: selectedLot.qty,  // Usa solo la quantit√† di questo lotto
        lots: [selectedLot]  // Solo questo lotto
      };
      
      appState.selectedProduct = lotProduct;
      appState.selectedLot = selectedLot;
      
      closeLotSelection();
      
      // Continua con il normale flusso di selezione prodotto
      document.querySelectorAll('.product-card').forEach(card => {
        card.classList.remove('selected');
      });
      
      // Trova la card del prodotto e selezionala
      const productCards = document.querySelectorAll('.product-card');
      const productIndex = appState.products.findIndex(p => p.id === productId);
      if (productCards[productIndex]) {
        productCards[productIndex].classList.add('selected');
      }
      
      // Mostra pannello con dati del lotto specifico
      showProductPanel(lotProduct, selectedLot);
    }
    
    // Funzione helper per controllare se una data √® entro N giorni
    function isWithinDays(dateString, days) {
      if (!dateString) return false;
      const date = new Date(dateString);
      const now = new Date();
      const diffTime = now - date;
      const diffDays = diffTime / (1000 * 60 * 60 * 24);
      return diffDays <= days;
    }
    
    // Mostra pannello prodotto (estratta dalla logica esistente)
    function showProductPanel(product, selectedLot = null) {
      // Mostra pannello inferiore
      const panel = document.getElementById('bottomPanel');
      panel.classList.add('active');
      
      // Aggiungi padding al main container per evitare sovrapposizioni
      document.querySelector('.main-container').classList.add('panel-open');

      // Popola info prodotto
      document.getElementById('selectedImage').src = product.image || '';
      document.getElementById('selectedName').textContent = product.name;
      
      // Mostra info specifiche del lotto se selezionato
      const lotDetails = selectedLot ? 
        `Lotto: ${selectedLot.name} | Giacenza: ${selectedLot.qty} ${product.uom}` :
        `${product.code ? product.code + ' | ' : ''}Giacenza: ${product.totalQty} ${product.uom}`;
      
      document.getElementById('selectedDetails').textContent = lotDetails;

      // Reset campi
      const qty = selectedLot ? selectedLot.qty : product.totalQty;
      document.getElementById('systemQuantity').textContent = qty;
      document.getElementById('systemUom').textContent = product.uom;
      document.getElementById('countedInput').value = '';
      document.getElementById('uomLabel').textContent = product.uom;
      document.getElementById('differenceIndicator').style.display = 'none';

      // Setup campi lotto e scadenza
      if (selectedLot) {
        // Se abbiamo un lotto specifico, precompilalo direttamente
        setupLotFieldsForSpecificLot(product, selectedLot);
      } else {
        setupLotFields(product);
      }
    }
    
    // Setup lotto specifico
    function setupLotFieldsForSpecificLot(product, lot) {
      document.getElementById('lotNumberInput').value = lot.name || '';
      document.getElementById('lotNumberInput').readOnly = true; // Non modificabile
      
      if (lot.expiry_date) {
        const expiryDate = new Date(lot.expiry_date);
        const formattedDate = expiryDate.toISOString().split('T')[0];
        document.getElementById('expiryDateInput').value = formattedDate;
      } else {
        document.getElementById('expiryDateInput').value = '';
      }
      
      // Imposta giacenza sistema per questo lotto
      document.getElementById('systemQuantity').textContent = lot.qty;
    }
    
    // Rendi le funzioni globali per gli onclick
    window.openCalculator = openCalculator;
    window.closeCalculator = closeCalculator;
    window.clearCalc = clearCalc;
    window.appendToCalc = appendToCalc;
    window.deleteLastCalc = deleteLastCalc;
    window.calculateResult = calculateResult;
    window.confirmCalculation = confirmCalculation;
    window.closeLotSelection = closeLotSelection;
    window.selectSpecificLot = selectSpecificLot;
    
    // Inizializzazione
    async function init() {
      console.log('Inizializzazione app Gestione Ubicazioni...');

      // Verifica connessione
      const connected = await checkConnection();
      if (!connected) {
        showNotification('Non connesso a Odoo. Verificare autenticazione.', 'error');
        return;
      }

      // Verifica e mostra utente loggato
      try {
        const currentUser = await getCurrentUser();
        if (currentUser && currentUser.name) {
          console.log('üë§ Utente loggato:', currentUser);
          showNotification(`üë§ Benvenuto ${currentUser.name}!`, 'success');
          
          // Salva l'utente corrente nello stato per uso futuro
          appState.currentUser = currentUser;
        } else {
          showNotification('‚ö†Ô∏è Utente non identificato', 'warning');
        }
      } catch (error) {
        console.error('Errore identificazione utente:', error);
        showNotification('‚ö†Ô∏è Errore identificazione utente', 'warning');
      }

      showNotification('‚úÖ App Gestione Ubicazioni pronta!', 'success');
    }

    // Avvia app quando DOM √® pronto
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>