<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#4f46e5">
  <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="expires" content="0">
  <meta http-equiv="pragma" content="no-cache">
  <title>LAPA Delivery v4.0 - Sistema Allegati Unificato - 09/09/2025</title>
  
  
  <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f9fafb;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: pan-y;
    }
    
    /* Ottimizzazioni per tablet Android */
    @media screen and (min-width: 768px) {
      body {
        font-size: 18px;
      }
      
      button {
        min-height: 48px;
        font-size: 16px;
      }
      
      input, textarea, select {
        min-height: 44px;
        font-size: 16px;
      }
      
      .modal-content {
        max-width: 600px;
      }
    }
    
    /* Prevent zoom on input focus for Android */
    input[type="text"],
    input[type="number"],
    input[type="email"],
    input[type="tel"],
    select,
    textarea {
      font-size: 16px !important;
    }
    
    /* Better touch targets */
    button, .btn, .option-btn {
      min-height: 44px;
      min-width: 44px;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: white;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      padding: 0 16px;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .header-title {
      flex: 1;
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
    }

    .header-info {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
      color: #6b7280;
    }

    .vehicle-badge {
      background: #e3f2fd;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      color: #1976d2;
    }

    .main-content {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 70px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      padding: 16px;
    }

    .stat-card {
      background: white;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .stat-number {
      font-size: 24px;
      font-weight: 700;
      color: #4f46e5;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }

    .delivery-card {
      background: white;
      border-radius: 12px;
      padding: 16px;
      margin: 0 16px 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      cursor: pointer;
      transition: all 0.2s;
    }

    .delivery-card:active {
      transform: scale(0.98);
    }

    .delivery-card.completed {
      opacity: 0.6;
      background: #f0f9ff;
    }

    .delivery-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .delivery-number {
      width: 32px;
      height: 32px;
      background: #4f46e5;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
    }

    .delivery-status {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      background: #f59e0b;
      color: white;
    }

    .delivery-status.completed {
      background: #10b981;
    }

    .customer-name {
      font-weight: 600;
      font-size: 16px;
      color: #1f2937;
      margin-bottom: 4px;
    }

    .customer-address {
      font-size: 14px;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .delivery-meta {
      display: flex;
      gap: 16px;
      font-size: 13px;
      color: #6b7280;
      margin-top: 8px;
    }

    .delivery-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .action-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .action-btn:active {
      transform: scale(0.95);
    }

    .btn-primary {
      background: #4f46e5;
      color: white;
    }

    .btn-success {
      background: #10b981;
      color: white;
    }

    .btn-secondary {
      background: #e5e7eb;
      color: #1f2937;
    }

    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: white;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-around;
      align-items: center;
      z-index: 1000;
    }

    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px;
      cursor: pointer;
      color: #6b7280;
      transition: all 0.2s;
    }

    .nav-item.active {
      color: #4f46e5;
    }

    .nav-icon {
      font-size: 24px;
    }

    .nav-label {
      font-size: 11px;
      font-weight: 500;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: white;
      z-index: 2000;
      display: none;
      flex-direction: column;
    }

    .modal.active {
      display: flex;
    }

    .modal-header {
      display: flex;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid #e5e7eb;
      background: white;
    }

    .modal-title {
      flex: 1;
      font-size: 18px;
      font-weight: 600;
    }

    .modal-close {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: #f9fafb;
      cursor: pointer;
      font-size: 20px;
    }

    .modal-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .info-section {
      background: #f9fafb;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .product-item {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 12px;
      margin-bottom: 6px;
    }

    .loading {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .loading.active {
      display: flex;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #e5e7eb;
      border-top-color: #4f46e5;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .toast {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      font-size: 14px;
      opacity: 0;
      transition: all 0.3s;
      z-index: 9999;
      pointer-events: none;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      color: #6b7280;
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    /* Scarico View Styles */
    .scarico-product-card {
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      transition: all 0.2s;
      cursor: pointer;
      position: relative;
    }

    .scarico-product-card:active {
      transform: scale(0.98);
    }

    .scarico-product-card.completed {
      opacity: 0.7;
      background: #f0fdf4;
    }

    .scarico-product-card.completed::after {
      content: '‚úì';
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #10b981;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }

    .scarico-product-image {
      width: 100%;
      height: 80px;
      background: #f3f4f6;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: #d1d5db;
    }

    .scarico-product-image img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      padding: 8px;
    }

    .scarico-product-info {
      padding: 10px;
    }

    .scarico-product-name {
      font-size: 12px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 6px;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .scarico-product-code {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 6px;
    }

    .scarico-qty-input {
      width: 100%;
      padding: 6px;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      margin-top: 6px;
    }

    /* Signature Pad */
    .signature-container {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      margin: 16px 0;
    }

    .signature-canvas {
      border: 2px dashed #d1d5db;
      border-radius: 8px;
      width: 100%;
      height: 200px;
      touch-action: none;
      background: #f9fafb;
    }

    .signature-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .signature-clear {
      background: #ef4444;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    /* Calculator */
    .calculator {
      background: white;
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 320px;
      margin: 0 auto;
    }

    .calc-display {
      background: #1f2937;
      color: #10b981;
      font-size: 32px;
      font-weight: 700;
      padding: 16px;
      border-radius: 12px;
      text-align: right;
      margin-bottom: 16px;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .calc-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .calc-btn {
      background: #f3f4f6;
      border: none;
      border-radius: 12px;
      padding: 20px;
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .calc-btn:active {
      transform: scale(0.95);
      background: #e5e7eb;
    }

    .calc-btn.zero {
      grid-column: span 2;
    }

    .calc-btn.clear {
      background: #ef4444;
      color: white;
    }

    .calc-btn.confirm {
      background: #10b981;
      color: white;
      grid-column: span 3;
      margin-top: 8px;
    }
    
    /* Pannello controllo POI */
    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 100;
      max-width: 220px;
    }
    
    .map-controls-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 4px;
      font-size: 14px;
      font-weight: 600;
      color: #4f46e5;
    }
    
    .map-controls-content {
      display: none;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e5e7eb;
    }
    
    .map-controls-content.active {
      display: block;
    }
    
    .poi-control {
      display: flex;
      align-items: center;
      margin: 6px 0;
      font-size: 13px;
    }
    
    .poi-control input {
      margin-right: 8px;
    }
    
    .poi-control label {
      cursor: pointer;
      user-select: none;
    }
  </style>



<div class="header">
  <div class="header-title">üì¶ LAPA Delivery</div>
  <div class="header-info">
    <span id="driverName">Caricamento...</span>
    <span class="vehicle-badge" id="vehicleName" style="display: none;"></span>
  </div>
</div>


<div class="main-content" id="mainContent">
  
  <div class="stats-container" id="statsContainer">
    <div class="stat-card">
      <div class="stat-number" id="totalDeliveries">0</div>
      <div class="stat-label">Totali</div>
    </div>
    <div class="stat-card">
      <div class="stat-number" id="completedDeliveries">0</div>
      <div class="stat-label">Completate</div>
    </div>
    <div class="stat-card">
      <div class="stat-number" id="remainingDeliveries">0</div>
      <div class="stat-label">Da fare</div>
    </div>
  </div>
  
  
  <div id="listView">
    
  </div>
  
  
  <div id="mapView" style="display: none; position: fixed; top: 60px; left: 0; right: 0; bottom: 70px; z-index: 100;">
    <div id="map" style="height: 100%; width: 100%;"></div>
    
    
    <div class="map-controls">
      <div class="map-controls-toggle" onclick="toggleMapControls()">
        <span>‚öôÔ∏è Filtri Mappa</span>
        <span id="controlsArrow">‚ñº</span>
      </div>
      <div class="map-controls-content" id="mapControlsContent">
        <div class="poi-control">
          <input type="checkbox" id="poiRestaurants" checked="" onchange="updateMapPOI()">
          <label for="poiRestaurants">üç¥ Ristoranti</label>
        </div>
        <div class="poi-control">
          <input type="checkbox" id="poiTransit" checked="" onchange="updateMapPOI()">
          <label for="poiTransit">üöâ Trasporti</label>
        </div>
        <div class="poi-control">
          <input type="checkbox" id="poiBusiness" onchange="updateMapPOI()">
          <label for="poiBusiness">üè¢ Attivit√†</label>
        </div>
        <div class="poi-control">
          <input type="checkbox" id="poiMedical" onchange="updateMapPOI()">
          <label for="poiMedical">üè• Ospedali</label>
        </div>
        <div class="poi-control">
          <input type="checkbox" id="poiParks" onchange="updateMapPOI()">
          <label for="poiParks">üå≥ Parchi</label>
        </div>
        <div class="poi-control">
          <input type="checkbox" id="poiSchools" onchange="updateMapPOI()">
          <label for="poiSchools">üè´ Scuole</label>
        </div>
      </div>
    </div>
  </div>
  
  
  <div id="scaricoView" style="display: none; position: fixed; top: 60px; left: 0; right: 0; bottom: 70px; overflow-y: auto;">
    
    <div style="background: white; padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; gap: 12px; position: sticky; top: 0; z-index: 10;">
      <button onclick="closeScaricoView()" style="width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border-radius: 8px; background: #f3f4f6; border: none; cursor: pointer; font-size: 20px;">
        ‚Üê
      </button>
      <div style="flex: 1; font-size: 18px; font-weight: 600;">Scarico Prodotti</div>
    </div>
    
    
    <div id="scaricoProductGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; padding: 12px; padding-bottom: 100px;">
      
    </div>
    
    
    <div style="position: fixed; bottom: 70px; left: 0; right: 0; background: white; border-top: 1px solid #e5e7eb; padding: 12px 16px; display: flex; align-items: center; gap: 12px;">
      <div style="flex: 1; display: flex; gap: 16px; align-items: center;">
        <div style="text-align: center;">
          <div style="font-size: 20px; font-weight: 700; color: #1f2937;" id="scaricoTotal">0</div>
          <div style="font-size: 11px; color: #6b7280;">Totali</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 20px; font-weight: 700; color: #10b981;" id="scaricoCompleted">0</div>
          <div style="font-size: 11px; color: #6b7280;">Scaricati</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 20px; font-weight: 700; color: #f59e0b;" id="scaricoRemaining">0</div>
          <div style="font-size: 11px; color: #6b7280;">Mancanti</div>
        </div>
      </div>
      <button id="completeScaricoBtn" onclick="completeScarico()" style="padding: 14px 28px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
        ‚úÖ Completa
      </button>
    </div>
  </div>
</div>


<div class="bottom-nav">
  <div class="nav-item active" onclick="switchView('list')">
    <div class="nav-icon">üìã</div>
    <div class="nav-label">Lista</div>
  </div>
  <div class="nav-item" onclick="switchView('map')">
    <div class="nav-icon">üó∫Ô∏è</div>
    <div class="nav-label">Mappa</div>
  </div>
  <div class="nav-item" onclick="optimizeRoute()">
    <div class="nav-icon">üéØ</div>
    <div class="nav-label">Ottimizza</div>
  </div>
  <div class="nav-item" onclick="reloadData()">
    <div class="nav-icon">üîÑ</div>
    <div class="nav-label">Aggiorna</div>
  </div>
  <div class="nav-item" onclick="checkBackorderProducts()" style="position: relative;">
    <div class="nav-icon">üì¶</div>
    <div class="nav-label">Residui</div>
    
    <span id="backorderBadge" style="
      position: absolute;
      top: 2px;
      right: 8px;
      background: #10b981;
      border-radius: 50%;
      width: 10px;
      height: 10px;
      display: block;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    "></span>
  </div>
</div>


<div class="modal" id="deliveryModal">
  <div class="modal-header">
    <div class="modal-title" id="modalTitle">Dettagli Consegna</div>
    <div class="modal-close" onclick="closeModal()">√ó</div>
  </div>
  
  <div class="modal-content">
    <div class="info-section">
      <h3 style="font-size: 16px; margin-bottom: 8px;">üìç Destinatario</h3>
      <div style="font-weight: 600;" id="modalCustomer">-</div>
      <div style="color: #6b7280; margin-top: 4px;" id="modalAddress">-</div>
      <div style="color: #6b7280; margin-top: 4px;" id="modalPhone">-</div>
    </div>
    
    <div class="info-section">
      <h3 style="font-size: 16px; margin-bottom: 8px;">üì¶ Prodotti</h3>
      <div id="modalProducts"></div>
    </div>
    
    <div class="info-section">
      <h3 style="font-size: 16px; margin-bottom: 8px;">üìù Note</h3>
      <div id="modalNotes" style="color: #6b7280;">Nessuna nota</div>
    </div>
    
    <div style="padding: 16px;">
      <button class="action-btn btn-primary" onclick="navigate()" style="width: 100%; margin-bottom: 8px;">
        üß≠ Naviga con Google Maps
      </button>
      <button class="action-btn btn-success" onclick="openScaricoFromModal()" style="width: 100%;">
        üì§ Vai allo Scarico
      </button>
    </div>
  </div>
</div>


<div class="loading" id="loading">
  <div class="spinner"></div>
</div>


<div class="toast" id="toast"></div>

<script>
// Version control and cache busting
const APP_VERSION = '4.0-UNIFIED-ATTACHMENTS';
console.log(`üöÄ LAPA Delivery v${APP_VERSION} - Sistema Allegati Unificato...`);
console.log('üìÖ Timestamp:', new Date().toISOString());
console.log('‚úÖ Added: Sistema allegati unificato per foto/documenti');
console.log('‚úÖ Added: Storage locale con IndexedDB');
console.log('‚úÖ Added: Sincronizzazione in background');
console.log('‚úÖ Added: Supporto offline completo');
console.log('üÜï Ottimizzato per tablet Android con storage aumentato');

// ============================================
// SISTEMA ALLEGATI UNIFICATO v2.0
// Supporta: Foto Camera, Galleria, PDF, Documenti
// Storage locale con IndexedDB e sync in background
// ============================================

// Inizializzazione IndexedDB con Dexie per storage locale
const db = new Dexie('LapaDeliveryDB');

// Version 3 - struttura corretta senza syncStatus come indice
db.version(3).stores({
  attachments: '++id, deliveryId, status, timestamp',
  pendingSync: '++id, type, data, timestamp, retries'
});

// Configurazione storage aumentato per tablet Android
const STORAGE_CONFIG = {
  maxFileSize: 50 * 1024 * 1024, // 50MB per file
  maxTotalStorage: 500 * 1024 * 1024, // 500MB totale
  compressionQuality: 0.8, // Qualit√† compressione immagini
  enableOfflineMode: true,
  autoSync: true,
  syncInterval: 30000 // 30 secondi
};

// Coda allegati temporanea
let attachmentsQueue = [];
let currentDeliveryAttachments = [];

// Sistema unificato per gestione allegati
class AttachmentManager {
  constructor() {
    this.queue = [];
    this.syncInProgress = false;
    this.initSync();
  }

  // Inizializza sincronizzazione automatica
  initSync() {
    if (STORAGE_CONFIG.autoSync) {
      setInterval(() => this.syncPendingAttachments(), STORAGE_CONFIG.syncInterval);
      
      // Sync quando torna online
      window.addEventListener('online', () => {
        console.log('üì∂ Connessione ripristinata - Avvio sync allegati...');
        this.syncPendingAttachments();
      });
    }
  }

  // Apre modal selezione tipo allegato
  async openAttachmentModal(deliveryId, context = 'delivery') {
    return new Promise((resolve) => {
      const modalHtml = `
        <div id="attachmentSelectorModal" class="modal" style="display: block;">
          <div class="modal-content" style="max-width: 400px; padding: 20px;">
            <div class="modal-header" style="margin-bottom: 20px;">
              <h3 style="color: #1f2937; font-size: 20px;">üìé Aggiungi Allegati</h3>
              <span class="close-modal" onclick="closeAttachmentModal()">&times;</span>
            </div>
            
            <div class="attachment-options" style="display: grid; gap: 12px;">
              <!-- Scatta Foto -->
              <button onclick="attachmentManager.capturePhoto('${deliveryId}', '${context}')" 
                      class="option-btn" style="display: flex; align-items: center; padding: 16px; background: #f3f4f6; border: 2px solid #e5e7eb; border-radius: 12px; cursor: pointer;">
                <span style="font-size: 28px; margin-right: 12px;">üì∑</span>
                <div style="text-align: left;">
                  <div style="font-weight: 600; color: #1f2937;">Scatta Foto</div>
                  <div style="font-size: 12px; color: #6b7280;">Usa la fotocamera</div>
                </div>
              </button>
              
              <!-- Carica dalla Galleria -->
              <button onclick="attachmentManager.selectFromGallery('${deliveryId}', '${context}')" 
                      class="option-btn" style="display: flex; align-items: center; padding: 16px; background: #f3f4f6; border: 2px solid #e5e7eb; border-radius: 12px; cursor: pointer;">
                <span style="font-size: 28px; margin-right: 12px;">üñºÔ∏è</span>
                <div style="text-align: left;">
                  <div style="font-weight: 600; color: #1f2937;">Galleria Foto</div>
                  <div style="font-size: 12px; color: #6b7280;">Scegli immagini esistenti</div>
                </div>
              </button>
              
              <!-- Carica Documenti -->
              <button onclick="attachmentManager.selectDocuments('${deliveryId}', '${context}')" 
                      class="option-btn" style="display: flex; align-items: center; padding: 16px; background: #f3f4f6; border: 2px solid #e5e7eb; border-radius: 12px; cursor: pointer;">
                <span style="font-size: 28px; margin-right: 12px;">üìÑ</span>
                <div style="text-align: left;">
                  <div style="font-weight: 600; color: #1f2937;">Documenti</div>
                  <div style="font-size: 12px; color: #6b7280;">PDF, Word, Excel...</div>
                </div>
              </button>
            </div>
            
            <!-- Lista allegati in coda -->
            <div id="attachmentQueueList" style="margin-top: 20px; max-height: 200px; overflow-y: auto;"></div>
            
            <!-- Pulsanti azione -->
            <div style="display: flex; gap: 12px; margin-top: 20px;">
              <button onclick="attachmentManager.confirmAttachments('${deliveryId}', '${context}')" 
                      class="btn-primary" style="flex: 1; padding: 12px; background: #4f46e5; color: white; border: none; border-radius: 8px; font-weight: 600;">
                ‚úÖ Conferma Allegati (<span id="attachmentCount">0</span>)
              </button>
              <button onclick="closeAttachmentModal()" 
                      class="btn-secondary" style="padding: 12px 24px; background: #f3f4f6; color: #6b7280; border: 2px solid #e5e7eb; border-radius: 8px; font-weight: 600;">
                Annulla
              </button>
            </div>
          </div>
        </div>
      `;
      
      // Aggiungi modal al DOM
      const modalContainer = document.createElement('div');
      modalContainer.innerHTML = modalHtml;
      document.body.appendChild(modalContainer);
      
      // Aggiorna lista allegati
      this.updateAttachmentsList();
    });
  }

  // Cattura foto dalla camera
  async capturePhoto(deliveryId, context) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment'; // Usa camera posteriore per tablet
    
    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (file) {
        await this.processFile(file, deliveryId, context);
        
        // Chiedi se vuole aggiungerne altre
        if (confirm('Vuoi scattare un\'altra foto?')) {
          this.capturePhoto(deliveryId, context);
        }
      }
    };
    
    input.click();
  }

  // Seleziona dalla galleria
  async selectFromGallery(deliveryId, context) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.multiple = true;
    
    input.onchange = async (e) => {
      const files = Array.from(e.target.files);
      for (const file of files) {
        await this.processFile(file, deliveryId, context);
      }
    };
    
    input.click();
  }

  // Seleziona documenti
  async selectDocuments(deliveryId, context) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.pdf,.doc,.docx,.xls,.xlsx,.txt,.csv';
    input.multiple = true;
    
    input.onchange = async (e) => {
      const files = Array.from(e.target.files);
      for (const file of files) {
        await this.processFile(file, deliveryId, context);
      }
    };
    
    input.click();
  }

  // Processa file (comprimi se necessario e aggiungi alla coda)
  async processFile(file, deliveryId, context) {
    try {
      // Verifica dimensione
      if (file.size > STORAGE_CONFIG.maxFileSize) {
        if (typeof showToast !== 'undefined') {
          showToast(`‚ö†Ô∏è File troppo grande (max ${STORAGE_CONFIG.maxFileSize / 1024 / 1024}MB)`, 'error');
        } else {
          console.error(`‚ö†Ô∏è File troppo grande (max ${STORAGE_CONFIG.maxFileSize / 1024 / 1024}MB)`);
        }
        return;
      }

      let processedData;
      let fileType = file.type;

      // Se √® un'immagine, comprimi
      if (file.type.startsWith('image/')) {
        processedData = await this.compressImage(file);
      } else {
        // Altri file, converti in base64
        processedData = await this.fileToBase64(file);
      }

      // Aggiungi alla coda
      const attachment = {
        id: Date.now() + Math.random(),
        deliveryId: deliveryId,
        context: context,
        fileName: file.name,
        fileType: fileType,
        fileSize: file.size,
        data: processedData,
        timestamp: new Date().toISOString(),
        status: 'pending',
        syncStatus: 'pending' // Cambiato da synced: false
      };

      this.queue.push(attachment);
      
      // Salva in IndexedDB
      await db.attachments.add(attachment);
      
      // Aggiorna UI
      this.updateAttachmentsList();
      
      if (typeof showToast !== 'undefined') {
        showToast(`‚úÖ ${file.name} aggiunto`, 'success');
      }
      
    } catch (error) {
      console.error('Errore processamento file:', error);
      if (typeof showToast !== 'undefined') {
        showToast('‚ùå Errore nel processamento del file', 'error');
      }
    }
  }

  // Comprimi immagine per ridurre spazio
  async compressImage(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Calcola dimensioni mantenendo aspect ratio
          let width = img.width;
          let height = img.height;
          const maxSize = 1920; // Max larghezza/altezza per tablet
          
          if (width > height && width > maxSize) {
            height = (maxSize / width) * height;
            width = maxSize;
          } else if (height > maxSize) {
            width = (maxSize / height) * width;
            height = maxSize;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // Disegna e comprimi
          ctx.drawImage(img, 0, 0, width, height);
          
          // Converti in base64 con compressione
          const base64 = canvas.toDataURL('image/jpeg', STORAGE_CONFIG.compressionQuality);
          resolve(base64.split(',')[1]);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
  }

  // Converti file in base64
  async fileToBase64(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.readAsDataURL(file);
    });
  }

  // Aggiorna lista allegati nella UI
  updateAttachmentsList() {
    const listElement = document.getElementById('attachmentQueueList');
    const countElement = document.getElementById('attachmentCount');
    
    if (!listElement) return;
    
    if (this.queue.length === 0) {
      listElement.innerHTML = '<p style="text-align: center; color: #9ca3af;">Nessun allegato selezionato</p>';
    } else {
      listElement.innerHTML = this.queue.map(att => `
        <div style="display: flex; align-items: center; padding: 8px; background: #f9fafb; border-radius: 8px; margin-bottom: 8px;">
          <span style="font-size: 20px; margin-right: 8px;">
            ${att.fileType.startsWith('image/') ? 'üñºÔ∏è' : 'üìÑ'}
          </span>
          <div style="flex: 1;">
            <div style="font-size: 14px; color: #1f2937;">${att.fileName}</div>
            <div style="font-size: 12px; color: #6b7280;">${(att.fileSize / 1024).toFixed(1)} KB</div>
          </div>
          <button onclick="attachmentManager.removeFromQueue('${att.id}')" 
                  style="padding: 4px 8px; background: #fee2e2; color: #dc2626; border: none; border-radius: 4px; cursor: pointer;">
            ‚úï
          </button>
        </div>
      `).join('');
    }
    
    if (countElement) {
      countElement.textContent = this.queue.length;
    }
  }

  // Rimuovi dalla coda
  async removeFromQueue(attachmentId) {
    this.queue = this.queue.filter(a => a.id != attachmentId);
    // Fix: converte attachmentId in numero se necessario
    const id = typeof attachmentId === 'string' ? parseFloat(attachmentId) : attachmentId;
    if (!isNaN(id)) {
      try {
        await db.attachments.where('id').equals(id).delete();
      } catch (error) {
        console.error('Errore rimozione da DB:', error);
      }
    }
    this.updateAttachmentsList();
  }

  // Conferma e salva allegati
  async confirmAttachments(deliveryId, context) {
    if (this.queue.length === 0) {
      if (typeof showToast !== 'undefined') {
        showToast('Seleziona almeno un allegato', 'warning');
      }
      return;
    }

    try {
      // Salva stato locale
      for (const attachment of this.queue) {
        attachment.status = 'saved';
        await db.attachments.put(attachment);
      }

      // Chiudi modal
      closeAttachmentModal();
      
      // Avvia sync se online
      if (navigator.onLine) {
        this.syncPendingAttachments();
      } else {
        if (typeof showToast !== 'undefined') {
          showToast(`üì± ${this.queue.length} allegati salvati localmente. Verranno caricati quando tornerai online.`, 'info');
        }
      }

      // Svuota coda temporanea
      currentDeliveryAttachments = [...this.queue];
      this.queue = [];
      
      return currentDeliveryAttachments;
      
    } catch (error) {
      console.error('Errore salvataggio allegati:', error);
      if (typeof showToast !== 'undefined') {
        showToast('‚ùå Errore nel salvataggio', 'error');
      }
    }
  }

  // Sincronizza allegati pendenti con Odoo
  async syncPendingAttachments() {
    if (this.syncInProgress || !navigator.onLine) return;
    
    this.syncInProgress = true;
    
    try {
      // Recupera tutti gli allegati e filtra quelli non sincronizzati
      const allAttachments = await db.attachments.toArray();
      const pendingAttachments = allAttachments.filter(a => 
        a.syncStatus === 'pending' || 
        a.syncStatus === undefined || 
        (!a.syncStatus && !a.synced)
      );
      
      if (pendingAttachments.length === 0) {
        this.syncInProgress = false;
        return;
      }

      console.log(`üì§ Sincronizzazione ${pendingAttachments.length} allegati...`);
      
      for (const attachment of pendingAttachments) {
        try {
          // Carica su Odoo
          const odooAttachmentId = await this.uploadToOdoo(attachment);
          
          if (odooAttachmentId) {
            // Marca come sincronizzato
            attachment.syncStatus = 'synced'; // Cambiato da synced: true
            attachment.odooId = odooAttachmentId;
            await db.attachments.put(attachment);
            
            console.log(`‚úÖ Allegato ${attachment.fileName} sincronizzato`);
          } else if (odooAttachmentId === null) {
            // callOdoo non disponibile, riprova pi√π tardi
            console.log(`‚è≥ Allegato ${attachment.fileName} in attesa (callOdoo non disponibile)`);
          }
        } catch (error) {
          console.error(`‚ùå Errore sync allegato ${attachment.fileName}:`, error);
          
          // Incrementa retry counter
          attachment.retries = (attachment.retries || 0) + 1;
          
          // Se troppi tentativi, marca come fallito
          if (attachment.retries > 5) {
            attachment.status = 'failed';
          }
          
          await db.attachments.put(attachment);
        }
      }
      
      if (typeof showToast !== 'undefined') {
        showToast('‚úÖ Allegati sincronizzati con successo', 'success');
      }
      
    } catch (error) {
      console.error('Errore sincronizzazione:', error);
    } finally {
      this.syncInProgress = false;
    }
  }

  // Upload singolo allegato su Odoo
  async uploadToOdoo(attachment) {
    try {
      // Verifica che callOdoo sia disponibile
      if (typeof callOdoo === 'undefined') {
        console.warn('callOdoo non disponibile, sync posticipato');
        return null;
      }
      
      const attachmentData = {
        name: attachment.fileName,
        datas: attachment.data,
        res_model: 'stock.picking',
        res_id: parseInt(attachment.deliveryId),
        type: 'binary',
        description: `Allegato ${attachment.context} - ${new Date(attachment.timestamp).toLocaleString('it-IT')}`
      };

      // Usa callOdoo invece di odoo.create - cerca sia nel scope locale che globale
      const odooCall = typeof callOdoo !== 'undefined' ? callOdoo : window.callOdoo;
      
      if (!odooCall) {
        console.warn('Funzione callOdoo non trovata, riprovare pi√π tardi');
        return null;
      }
      
      const result = await odooCall('ir.attachment', 'create', [attachmentData]);
      
      // callOdoo ritorna direttamente l'ID o un array di ID
      return Array.isArray(result) ? result[0] : result;
      
    } catch (error) {
      console.error('Errore upload Odoo:', error);
      throw error;
    }
  }

  // Recupera allegati salvati per una consegna
  async getDeliveryAttachments(deliveryId) {
    try {
      // Fix: assicura che deliveryId sia una stringa valida
      const id = deliveryId ? String(deliveryId) : '';
      if (!id) return [];
      
      // Usa where su deliveryId che √® indicizzato
      const attachments = await db.attachments
        .where('deliveryId')
        .equals(id)
        .toArray();
      
      return attachments;
    } catch (error) {
      console.error('Errore recupero allegati:', error);
      // Fallback: recupera tutti e filtra
      try {
        const allAttachments = await db.attachments.toArray();
        return allAttachments.filter(a => String(a.deliveryId) === id);
      } catch (e) {
        console.error('Anche il fallback √® fallito:', e);
        return [];
      }
    }
  }

  // Pulizia vecchi allegati sincronizzati (dopo 7 giorni)
  async cleanupOldAttachments() {
    try {
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      // Recupera tutti gli allegati e filtra
      const allAttachments = await db.attachments.toArray();
      
      const toDelete = allAttachments.filter(att => 
        (att.syncStatus === 'synced' || att.synced === true) &&
        new Date(att.timestamp) < sevenDaysAgo
      );
      
      for (const att of toDelete) {
        await db.attachments.delete(att.id);
      }
      
      console.log(`üßπ Puliti ${toDelete.length} allegati vecchi`);
    } catch (error) {
      console.error('Errore pulizia allegati:', error);
    }
  }
}

// Inizializza manager allegati
const attachmentManager = new AttachmentManager();

// Inizializza e controlla il database all'avvio
// Usa open() invece di on('ready') per evitare errori
db.open().then(() => {
  console.log('‚úÖ Database IndexedDB pronto');
  
  // Pulizia e migrazione dati se necessario
  return db.attachments.toArray();
}).then(attachments => {
  let needsUpdate = false;
  const updates = [];
  
  attachments.forEach(att => {
    if (!att.syncStatus && att.synced !== undefined) {
      att.syncStatus = att.synced ? 'synced' : 'pending';
      delete att.synced;
      needsUpdate = true;
      updates.push(db.attachments.put(att));
    }
  });
  
  if (needsUpdate) {
    return Promise.all(updates).then(() => {
      console.log('üìù Migrati vecchi record al nuovo formato');
    });
  }
}).catch(err => {
  // Solo log errore, non bloccare l'app
  console.warn('Errore inizializzazione database (non critico):', err);
  // Non usare showToast qui perch√© potrebbe non essere ancora definito
});

// Funzione helper per chiudere modal
function closeAttachmentModal() {
  const modal = document.getElementById('attachmentSelectorModal');
  if (modal) {
    modal.remove();
  }
}

// Wrapper per aprire modal allegati senza bloccare il flusso
async function openAttachmentModalForSignature() {
  // Apri modal allegati
  await attachmentManager.openAttachmentModal(scaricoState.currentDelivery.id, 'firma');
  
  // Aggiorna contatore allegati quando si chiude
  updateAttachmentCount('firma');
}

async function openAttachmentModalForPhoto() {
  await attachmentManager.openAttachmentModal(scaricoState.currentDelivery.id, 'solo_foto');
  updateAttachmentCount('solo_foto');
}

async function openAttachmentModalForPayment() {
  await attachmentManager.openAttachmentModal(scaricoState.currentDelivery.id, 'pagamento');
  updateAttachmentCount('pagamento');
}

async function openAttachmentModalForReso(deliveryId) {
  await attachmentManager.openAttachmentModal(deliveryId, 'reso');
  updateAttachmentCount('reso', deliveryId);
}

// Aggiorna contatore allegati nel modal
async function updateAttachmentCount(context, deliveryId = null) {
  const id = deliveryId || scaricoState.currentDelivery.id;
  const attachments = await attachmentManager.getDeliveryAttachments(id);
  const contextAttachments = attachments.filter(a => a.context === context);
  
  let countElement;
  if (context === 'firma') {
    countElement = document.getElementById('selectedAttachmentsCount');
  } else if (context === 'solo_foto') {
    countElement = document.getElementById('photoOnlyAttachmentsCount');
  } else if (context === 'pagamento') {
    countElement = document.getElementById('paymentAttachmentsCount');
  } else if (context === 'reso') {
    countElement = document.getElementById('resoAttachmentsCount');
  }
  
  if (countElement && contextAttachments.length > 0) {
    countElement.innerHTML = `‚úÖ ${contextAttachments.length} allegat${contextAttachments.length > 1 ? 'i' : 'o'} aggiunt${contextAttachments.length > 1 ? 'i' : 'o'}`;
    countElement.style.color = '#059669';
  }
}

// Check storage disponibile
async function checkStorageQuota() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const {usage, quota} = await navigator.storage.estimate();
    const percentUsed = (usage / quota * 100).toFixed(2);
    console.log(`üìä Storage: ${(usage / 1024 / 1024).toFixed(2)}MB di ${(quota / 1024 / 1024).toFixed(2)}MB (${percentUsed}%)`);
    
    // Se supera 80%, pulisci vecchi allegati
    if (percentUsed > 80) {
      await attachmentManager.cleanupOldAttachments();
    }
  }
}

// Check storage ogni 5 minuti
setInterval(checkStorageQuota, 5 * 60 * 1000);

// ============================================
// OTTIMIZZAZIONI PER TABLET ANDROID
// ============================================

// Detect Android tablet
function isAndroidTablet() {
  const userAgent = navigator.userAgent.toLowerCase();
  const isAndroid = userAgent.indexOf('android') > -1;
  const isTablet = Math.min(window.screen.width, window.screen.height) >= 600;
  return isAndroid && isTablet;
}

// Applica ottimizzazioni specifiche per Android
if (isAndroidTablet()) {
  console.log('üì± Rilevato Tablet Android - Applico ottimizzazioni');
  
  // Richiedi permesso storage persistente
  if ('storage' in navigator && 'persist' in navigator.storage) {
    navigator.storage.persist().then(granted => {
      if (granted) {
        console.log('‚úÖ Storage persistente garantito');
      }
    });
  }
  
  // Previeni zoom accidentale
  document.addEventListener('gesturestart', function(e) {
    e.preventDefault();
  });
  
  // Migliora performance scroll - permetti scroll su main-content
  document.addEventListener('touchmove', function(e) {
    const mainContent = document.getElementById('mainContent');
    // Previeni solo se non siamo nel contenitore principale o suoi figli
    if (!mainContent.contains(e.target) && e.target.scrollHeight <= e.target.clientHeight) {
      e.preventDefault();
    }
  }, { passive: false });
  
  // Aumenta timeout per tablet pi√π lenti
  STORAGE_CONFIG.syncInterval = 60000; // 1 minuto invece di 30 secondi
}

// Request notification permission for background sync
if ('Notification' in window && Notification.permission === 'default') {
  Notification.requestPermission();
}

// ============================================
// FINE SISTEMA ALLEGATI UNIFICATO
// ============================================

// State - definito prima di qualsiasi utilizzo
let state = {
  deliveries: [],
  currentDelivery: null,
  completedDeliveries: new Set(),
  map: null,
  markers: [],
  currentPosition: null,
  userId: null,
  employeeId: null,
  employeeName: null,
  vehicleName: null,
  deliveryETAs: {},  // Memorizza gli ETA calcolati per ogni consegna
  routeStartTime: null,  // Orario di inizio del giro
  version: APP_VERSION
};

// Conta ordini residui (backorder)
function countBackorderProducts() {
  // Trova tutti gli ordini residui (backorder)
  const backorders = state.deliveries.filter(d => 
    d.isBackorder || d.isResiduo || d.name?.includes('/BO')
  );
  
  // Ritorna il numero di ordini residui (non i prodotti singoli)
  return backorders.length;
}

// Aggiorna il badge dei prodotti residui (pallino rosso/verde)
function updateBackorderBadge() {
  const badge = document.getElementById('backorderBadge');
  if (!badge) return;
  
  const count = countBackorderProducts();
  
  if (count > 0) {
    // Pallino rosso = ci sono residui
    badge.style.background = '#ef4444';
  } else {
    // Pallino verde = tutto ok
    badge.style.background = '#10b981';
  }
}

// Mostra popup prodotti residui
function checkBackorderProducts() {
  const count = countBackorderProducts();
  
  // Crea il modal
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <div class="modal-title">üì¶ Merce da Sistemare</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        ${count > 0 ? `
          <!-- Avviso prodotti da sistemare -->
          <div style="background: #fef2f2; border: 2px solid #f87171; padding: 20px; border-radius: 8px; margin-bottom: 16px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 8px;">‚ö†Ô∏è</div>
            <div style="font-size: 20px; font-weight: 600; color: #991b1b; margin-bottom: 8px;">
              Prodotti da sistemare!
            </div>
            <div style="color: #7f1d1d; font-size: 16px;">
              Ci sono prodotti da rimettere a posto negli scaffali
            </div>
          </div>
          
          <!-- Pulsante per aprire app di sistemazione -->
          <button onclick="openStockApp()" style="
            width: 100%;
            padding: 16px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
          ">
            üì± Apri App Sistemazione
          </button>
          
        ` : `
          <!-- Nessun prodotto residuo -->
          <div style="background: #d1fae5; border: 2px solid #10b981; padding: 20px; border-radius: 8px; text-align: center; margin-bottom: 16px;">
            <div style="font-size: 48px; margin-bottom: 8px;">‚úÖ</div>
            <div style="font-size: 18px; font-weight: 600; color: #065f46; margin-bottom: 4px;">
              Tutto a posto!
            </div>
            <div style="color: #047857; font-size: 14px;">
              Non ci sono prodotti da sistemare
            </div>
          </div>
          
          <!-- Pulsante per aprire app di sistemazione sempre visibile -->
          <button onclick="openStockApp()" style="
            width: 100%;
            padding: 16px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
          ">
            üì± Apri App Sistemazione
          </button>
        `}
        
        <!-- Pulsante chiudi -->
        <button onclick="this.closest('.modal').remove()" style="
          width: 100%;
          padding: 12px;
          margin-top: 12px;
          background: #6b7280;
          color: white;
          border: none;
          border-radius: 8px;
          font-size: 14px;
          cursor: pointer;
        ">
          Chiudi
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

// Funzione per aprire l'app di sistemazione scaffali
function openStockApp() {
  // URL PLACEHOLDER - sostituisci con l'URL reale della tua app
  const stockAppUrl = 'https://www.lapa.ch/sistemare-ritorni-dal-furgone'; // <-- MODIFICA QUI CON IL TUO URL
  
  // Apre in una nuova finestra/tab
  window.open(stockAppUrl, '_blank');
  
  // Opzionale: chiudi il modal dopo aver aperto l'app
  document.querySelectorAll('.modal').forEach(m => m.remove());
}

// Initialize
async function init() {
  console.log('üöÄ Inizializzazione LAPA Delivery...');
  showLoading(true);
  
  try {
    await getSession();
    initMap();
    await loadDeliveries();
    startGPS();
    
    // Assicurati che l'app si apra sulla vista Lista
    switchView('list');
    
    console.log('‚úÖ App pronta!');
  } catch (error) {
    console.error('‚ùå Errore:', error);
    showToast('Errore: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Get session info
async function getSession() {
  console.log('üìã Recupero sessione...');
  
  try {
    const response = await fetch('/web/session/get_session_info', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "call",
        params: {},
        id: Math.floor(Math.random() * 1e9)
    })
  });
  
  const data = await response.json();
  if (data.result) {
    state.userId = data.result.uid;
    console.log('User ID:', state.userId);
    
    // Get employee info
    const employee = await callOdoo('hr.employee', 'search_read', [], {
      domain: [['user_id', '=', state.userId]],
      fields: ['id', 'name'],
      limit: 1
    });
    
    if (employee && employee.length > 0) {
      state.employeeId = employee[0].id;
      state.employeeName = employee[0].name;
      document.getElementById('driverName').textContent = employee[0].name;
      console.log('Autista:', employee[0].name, '(ID:', employee[0].id, ')');
    } else {
      document.getElementById('driverName').textContent = 'Tutte le consegne';
      console.log('Nessun employee associato, mostro tutte le consegne');
    }
  } else {
    console.warn('‚ö†Ô∏è Nessuna sessione trovata, l\'app potrebbe non funzionare correttamente');
    showToast('‚ö†Ô∏è Nessuna sessione Odoo attiva. L\'app deve essere eseguita su un server Odoo.', 'error');
  }
  } catch (error) {
    console.error('‚ùå Errore nel recupero della sessione:', error);
    console.log('‚ÑπÔ∏è L\'app richiede di essere eseguita su un server Odoo con autenticazione attiva.');
    showToast('‚ö†Ô∏è Errore connessione: l\'app deve essere eseguita su un server Odoo', 'error');
    throw error;
  }
}

// Call Odoo RPC
async function callOdoo(model, method, args, kwargs = {}) {
  try {
    // Validazione parametri
    if (!model || !method) {
      throw new Error('Model e method sono obbligatori');
    }
    
    // Assicurati che args sia sempre un array
    if (!Array.isArray(args)) {
      args = [];
    }
    
    const response = await fetch('/web/dataset/call_kw', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "call",
        params: {
          model: model,
          method: method,
          args: args,
          kwargs: kwargs || {}
        },
        id: Math.floor(Math.random() * 1e9)
      })
    }).catch(error => {
      console.error('‚ùå Errore di rete:', error);
      throw new Error('Impossibile connettersi al server Odoo. Verificare che l\'app sia eseguita su un server Odoo.');
    });
    
    if (!response.ok) {
      console.error(`‚ùå HTTP Error ${response.status}`);
      if (response.status === 404) {
        throw new Error('Endpoint Odoo non trovato. L\'app deve essere eseguita su un server Odoo.');
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.error) {
      const errorMsg = data.error.data?.message || data.error.message || 'RPC Error';
      console.error(`Odoo RPC Error (${model}.${method}):`, errorMsg);
      throw new Error(errorMsg);
    }
    
    return data.result;
  } catch (error) {
    console.error(`Errore chiamata Odoo ${model}.${method}:`, error);
    throw error;
  }
}

// Load deliveries
async function loadDeliveries() {
  console.log('üì¶ Carico consegne di oggi...');
  
  try {
  
  // Get today's date range - Usa formato locale corretto
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const todayStr = `${year}-${month}-${day}`;
  
  // Domani
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const tomorrowYear = tomorrow.getFullYear();
  const tomorrowMonth = String(tomorrow.getMonth() + 1).padStart(2, '0');
  const tomorrowDay = String(tomorrow.getDate()).padStart(2, '0');
  const tomorrowStr = `${tomorrowYear}-${tomorrowMonth}-${tomorrowDay}`;
  
  console.log(`üìÖ Data di oggi: ${todayStr} (locale: ${now.toLocaleDateString('it-IT')})`);
  
  // Build domain - First date filter, then other filters
  let domain = [
    '&',  // Operatore AND per combinare i filtri data
    ['scheduled_date', '>=', todayStr + ' 00:00:00'],     // Data programmata >= inizio oggi
    ['scheduled_date', '<=', todayStr + ' 23:59:59'],      // Data programmata <= fine oggi
    ['name', 'like', 'WH/OUT'],
    ['state', 'in', ['assigned', 'done']]  // Solo ASSIGNED (da consegnare) e DONE (consegnati)
  ];
  
  // ALWAYS add driver filter if we have an employee
  if (state.employeeId) {
    domain.push(['driver_id', '=', state.employeeId]);
    console.log(`Filtro documenti con scheduled_date di OGGI (${todayStr}) per driver_id =`, state.employeeId);
  } else {
    // If no employee, show nothing or very limited
    console.log('ATTENZIONE: Nessun driver associato all\'utente');
    domain.push(['driver_id', '=', false]); // Show only unassigned
  }
  
  // Load pickings
  const pickings = await callOdoo('stock.picking', 'search_read', [], {
    domain: domain,
    fields: [
      'id', 'name', 'partner_id', 'scheduled_date', 
      'state', 'note', 'move_ids', 'origin',
      'driver_id', 'vehicle_id', 'carrier_id',
      'backorder_id'  // Campo per identificare ordini residui
    ],
    limit: 100,
    order: 'scheduled_date asc, name asc'
  });
  
  console.log(`Trovati ${pickings.length} WH/OUT con scheduled_date di oggi per il driver`);
  
  // I risultati sono gi√† filtrati per oggi dal domain Odoo, non serve filtro client-side
  let todayPickings = pickings;
  
  // If no deliveries today, inform the user
  if (todayPickings.length === 0) {
    console.log('Nessuna consegna programmata per oggi');
    showToast('Nessuna consegna programmata per oggi', 'info');
  }
  
  // Get vehicle info from first picking if available
  if (todayPickings.length > 0 && todayPickings[0].vehicle_id) {
    const vehicleFullName = todayPickings[0].vehicle_id[1];
    // Extract license plate (usually after / or at the end)
    let licensePlate = vehicleFullName;
    
    // Try to extract license plate pattern (2 letters + numbers + 2 letters)
    const plateMatch = vehicleFullName.match(/[A-Z]{2}\s*\d+\s*[A-Z]{2}/i);
    if (plateMatch) {
      licensePlate = plateMatch[0];
    } else if (vehicleFullName.includes('/')) {
      // If there's a slash, take the part after it
      const parts = vehicleFullName.split('/');
      licensePlate = parts[parts.length - 1].trim();
    }
    
    state.vehicleName = licensePlate;
    document.getElementById('vehicleName').textContent = 'üöö ' + licensePlate;
    document.getElementById('vehicleName').style.display = 'inline-block';
  }
  
  state.deliveries = [];
  
  // Map per raggruppare consegne per cliente+indirizzo
  const deliveryGroups = new Map();
  
  // Process each picking
  for (const picking of todayPickings) {
    if (!picking.partner_id) continue;
    
    // Get partner details
    const partners = await callOdoo('res.partner', 'search_read', [], {
      domain: [['id', '=', picking.partner_id[0]]],
      fields: ['name', 'street', 'street2', 'city', 'zip', 'phone', 'mobile', 'partner_latitude', 'partner_longitude'],
      limit: 1
    });
    
    const partner = partners[0];
    
    // Get products (simplified - just names and quantities)
    let products = [];
    if (picking.move_ids && picking.move_ids.length > 0) {
      const moves = await callOdoo('stock.move', 'search_read', [], {
        domain: [['id', 'in', picking.move_ids]],
        fields: ['product_id', 'product_uom_qty'],
        limit: 100
      });
      
      products = moves.map(m => ({
        name: m.product_id[1],
        qty: m.product_uom_qty
      }));
    }
    
    // Build address
    let address = '';
    if (partner.street) address += partner.street;
    if (partner.street2) address += ', ' + partner.street2;
    if (partner.zip || partner.city) {
      address += ', ';
      if (partner.zip) address += partner.zip + ' ';
      if (partner.city) address += partner.city;
    }
    
    // Crea una chiave univoca per raggruppare per cliente+indirizzo
    const groupKey = `${partner.name}_${address.trim()}`.toLowerCase();
    
    // Debug backorder_id per capire cosa arriva da Odoo
    console.log(`üì¶ Picking ${picking.name}:`, {
      backorder_id: picking.backorder_id,
      tipo: typeof picking.backorder_id,
      isArray: Array.isArray(picking.backorder_id)
    });
    
    const deliveryData = {
      id: picking.id,
      name: picking.name,
      customer: partner.name,
      customerName: partner.name,
      address: address.trim(),
      phone: partner.phone || partner.mobile || '',
      lat: partner.partner_latitude || null,
      lng: partner.partner_longitude || null,
      products: products,
      note: picking.note || '',
      state: picking.state,
      origin: picking.origin || '',
      carrier: picking.carrier_id ? picking.carrier_id[1] : '',
      scheduledDate: picking.scheduled_date,
      backorderId: picking.backorder_id,
      // Se backorder_id √® popolato (non false/null/undefined), √® un ordine residuo
      isBackorder: picking.backorder_id ? true : false,
      isResiduo: picking.backorder_id ? true : false,  // Duplicato per sicurezza
      completed: picking.state === 'done' || state.completedDeliveries.has(picking.id)
    };
    
    // RAGGRUPPA SOLO ORDINI PRONTI DA CONSEGNARE (non completati, non residui)
    const canGroup = !deliveryData.completed && 
                     !deliveryData.isBackorder && 
                     !deliveryData.isResiduo && 
                     deliveryData.state !== 'done';
    
    if (canGroup && deliveryGroups.has(groupKey)) {
      const existingGroup = deliveryGroups.get(groupKey);
      
      // Verifica che anche il gruppo esistente sia pronto (non completato/residuo)
      const existingCanGroup = !existingGroup.completed && 
                              !existingGroup.isBackorder && 
                              !existingGroup.isResiduo && 
                              existingGroup.state !== 'done';
      
      if (existingCanGroup) {
        // RAGGRUPPA: entrambi sono ordini pronti da consegnare
        console.log(`‚úÖ Raggruppo ${picking.name} con gruppo esistente per ${partner.name}`);
        
        // Aggiungi i documenti collegati
        existingGroup.linkedPickings.push({
          id: picking.id,
          name: picking.name,
          state: picking.state,
          origin: picking.origin || '',
          completed: false
        });
        
        // Combina i prodotti
        existingGroup.products = existingGroup.products.concat(products);
        
        // Combina le note (se diverse)
        if (picking.note && !existingGroup.note.includes(picking.note)) {
          existingGroup.note += '\n' + picking.note;
        }
        
        // Il gruppo rimane non completato (tutti sono pronti)
        existingGroup.completed = false;
        
      } else {
        // NON raggruppare: il gruppo esistente non √® pronto
        console.log(`‚ö†Ô∏è Non raggruppo ${picking.name} - gruppo esistente non √® pronto da consegnare`);
        const uniqueKey = `${groupKey}_${picking.id}`;
        deliveryData.isGrouped = false;
        deliveryData.linkedPickings = [{
          id: picking.id,
          name: picking.name,
          state: picking.state,
          origin: picking.origin || '',
          completed: deliveryData.completed
        }];
        deliveryGroups.set(uniqueKey, deliveryData);
      }
      
    } else {
      // Non pu√≤ essere raggruppato (completato/residuo) o √® il primo del gruppo
      if (!canGroup && deliveryGroups.has(groupKey)) {
        // Esiste gi√† un gruppo ma questo documento non pu√≤ essere raggruppato
        console.log(`‚ö†Ô∏è ${picking.name} non pu√≤ essere raggruppato (completato/residuo)`);
        const uniqueKey = `${groupKey}_${picking.id}`;
      } else if (canGroup) {
        console.log(`üì¶ Primo documento per ${partner.name} - potenzialmente raggruppabile`);
      }
      
      deliveryData.isGrouped = false;
      deliveryData.linkedPickings = [{
        id: picking.id,
        name: picking.name,
        state: picking.state,
        origin: picking.origin || '',
        completed: deliveryData.completed
      }];
      
      // Usa chiave unica se non pu√≤ essere raggruppato
      const finalKey = canGroup ? groupKey : `${groupKey}_${picking.id}`;
      deliveryGroups.set(finalKey, deliveryData);
    }
  }
  
  // Converti la Map in array e marca i gruppi con pi√π documenti
  for (const [key, delivery] of deliveryGroups) {
    if (delivery.linkedPickings.length > 1) {
      delivery.isGrouped = true;
      // Crea un nome combinato per i documenti raggruppati
      delivery.name = delivery.linkedPickings.map(p => p.name).join(' + ');
      // Conta totale prodotti unici
      delivery.totalDocs = delivery.linkedPickings.length;
    }
    state.deliveries.push(delivery);
  }
  
  // Update UI
  renderDeliveries();
  updateStats();
  updateMap();
  
  console.log(`‚úÖ Caricate ${state.deliveries.length} consegne`);
  
  // Debug ordini residui
  const residui = state.deliveries.filter(d => d.isBackorder || d.backorderId);
  if (residui.length > 0) {
    console.log(`üî∂ Trovati ${residui.length} ordini residui:`, residui.map(r => r.name));
  }
  
  // Calcola ETA per tutte le consegne attive
  await calculateETAsForDeliveries();
  
  // Aggiorna scheduled_date in Odoo per tutte le consegne
  const activeDeliveries = state.deliveries.filter(d => 
    d.state !== 'done' && !d.completed && !d.isBackorder
  );
  
  for (const delivery of activeDeliveries) {
    if (state.deliveryETAs[delivery.id]) {
      await updateOdooScheduledDate(delivery.id);
    }
  }
  
  // Ricarica la UI con gli ETA
  renderDeliveries();
  
  } catch (error) {
    console.error('‚ùå Errore nel caricamento delle consegne:', error);
    showToast('Errore nel caricamento delle consegne: ' + error.message, 'error');
    
    // Mostra lista vuota se c'√® un errore
    state.deliveries = [];
    renderDeliveries();
    updateStats();
  }
}

// Render deliveries list
function renderDeliveries() {
  const container = document.getElementById('listView');
  
  // Aggiorna il badge dei prodotti residui
  updateBackorderBadge();
  
  if (state.deliveries.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">üì¶</div>
        <div>Nessuna consegna da mostrare</div>
      </div>
    `;
    return;
  }
  
  container.innerHTML = '';
  
  // Separate deliveries in 3 categories: active, backorders (treated as completed), completed
  const activeDeliveries = state.deliveries.filter(d => d.state !== 'done' && !d.completed && !d.isBackorder);
  const backorderDeliveries = state.deliveries.filter(d => d.isBackorder);  // Tutti i backorder, anche se gi√† completati
  const completedDeliveries = state.deliveries.filter(d => (d.state === 'done' || d.completed) && !d.isBackorder);  // Solo completati NON backorder
  
  // DEBUG: Log ordini residui trovati
  if (backorderDeliveries.length > 0) {
    console.log('üî¥ ORDINI RESIDUI TROVATI:', backorderDeliveries.map(d => ({
      name: d.name,
      isBackorder: d.isBackorder,
      backorderId: d.backorderId
    })));
  }
  
  // Render active deliveries first
  if (activeDeliveries.length > 0) {
    const activeHeader = document.createElement('div');
    activeHeader.style.cssText = 'padding: 16px 16px 8px; font-weight: 600; color: #6b7280; font-size: 14px;';
    activeHeader.textContent = 'üìã Da Consegnare';
    container.appendChild(activeHeader);
  }
  
  activeDeliveries.forEach((delivery, index) => {
    const card = document.createElement('div');
    card.className = 'delivery-card' + (delivery.completed ? ' completed' : '');
    card.onclick = () => openDelivery(delivery);
    
    card.innerHTML = `
      <div class="delivery-header">
        <div class="delivery-number">${index + 1}</div>
        <div class="delivery-status ${delivery.completed ? 'completed' : ''}">
          ${delivery.completed ? 'Completata' : delivery.state}
        </div>
      </div>
      <div class="customer-name">
        ${delivery.customer}
        ${delivery.isGrouped ? `<span style="background: #fbbf24; color: #78350f; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px; font-weight: 600;">üì¶ ${delivery.totalDocs} DOC</span>` : ''}
      </div>
      <div class="customer-address">${delivery.address}</div>
      ${delivery.phone ? `<div style="font-size: 13px; color: #6b7280;">üìû ${delivery.phone}</div>` : ''}
      ${state.deliveryETAs[delivery.id] ? `
        <div style="padding: 6px; background: #e0f2fe; border-radius: 6px; margin: 8px 0; display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 20px;">‚è∞</span>
          <div>
            <div style="font-size: 16px; font-weight: 600; color: #0369a1;">Arrivo previsto: ${state.deliveryETAs[delivery.id].etaString}</div>
            <div style="font-size: 11px; color: #64748b;">Tempo di viaggio: ${state.deliveryETAs[delivery.id].travelTime} min + 15 min fermata</div>
          </div>
        </div>
      ` : ''}
      <div class="delivery-meta">
        <span>üì¶ ${delivery.products.length} prodotti</span>
        <span>üìÑ ${delivery.name}</span>
        ${delivery.carrier ? `<span>üöö ${delivery.carrier}</span>` : ''}  
      </div>
      ${delivery.isGrouped ? `
        <div style="margin: 8px 0; padding: 8px; background: #fef3c7; border-radius: 6px; font-size: 12px; color: #78350f;">
          <strong>Documenti raggruppati:</strong> ${delivery.linkedPickings.map(p => p.name).join(', ')}
        </div>
      ` : ''}
      <div class="delivery-actions">
        <button class="action-btn btn-primary" onclick="event.stopPropagation(); navigateTo(${delivery.lat}, ${delivery.lng})">
          üß≠ Naviga
        </button>
        <button class="action-btn btn-success" onclick="event.stopPropagation(); openScaricoView(state.deliveries.find(d => d.id === ${delivery.id}))">
          üì§ Scarica
        </button>
      </div>
    `;
    
    container.appendChild(card);
  });
  
  // 2. Render backorder deliveries (ordini residui) - TRATTATI COME COMPLETATI CON RISERVA
  if (backorderDeliveries.length > 0) {
    const backorderHeader = document.createElement('div');
    backorderHeader.style.cssText = 'padding: 16px 16px 8px; font-weight: 600; color: #f59e0b; font-size: 14px; margin-top: 16px;';
    backorderHeader.textContent = '‚ö†Ô∏è Ordini Residui (Completati con riserva)';
    container.appendChild(backorderHeader);
    
    backorderDeliveries.forEach((delivery, index) => {
      const card = document.createElement('div');
      card.className = 'delivery-card';
      card.style.borderLeft = '4px solid #f59e0b';  // Bordo arancione per ordini residui
      card.onclick = () => openDelivery(delivery);
      
      card.innerHTML = `
        <div class="delivery-header">
          <div class="delivery-number" style="background: #f59e0b;">R${index + 1}</div>
          <div class="delivery-status" style="background: #fef3c7; color: #92400e;">
            üîí Residuo Bloccato
          </div>
        </div>
        <div class="customer-name">${delivery.customer}</div>
        <div class="customer-address">${delivery.address}</div>
        ${delivery.phone ? `<div style="font-size: 13px; color: #6b7280;">üìû ${delivery.phone}</div>` : ''}
        <div style="margin-top: 8px; padding: 8px; background: #fee2e2; border-radius: 6px; font-size: 12px; color: #991b1b;">
          <strong>‚ö†Ô∏è Ordine Residuo:</strong> Completato con riserva - Solo visualizzazione
        </div>
        <div class="delivery-meta">
          <span>üì¶ ${delivery.products.length} prodotti</span>
          <span>üìÑ ${delivery.name}</span>
          ${delivery.carrier ? `<span>üöö ${delivery.carrier}</span>` : ''}
        </div>
        <div class="delivery-actions">
          <button class="action-btn btn-primary" onclick="event.stopPropagation(); navigateTo(${delivery.lat}, ${delivery.lng})">
            üß≠ Naviga
          </button>
          <button class="action-btn" style="background: #f59e0b; color: white;" onclick="event.stopPropagation(); openScaricoView(state.deliveries.find(d => d.id === ${delivery.id}))">
            üëÅÔ∏è Visualizza Prodotti
          </button>
        </div>
      `;
      
      container.appendChild(card);
    });
  }
  
  // 3. Render completed deliveries
  if (completedDeliveries.length > 0) {
    const completedHeader = document.createElement('div');
    completedHeader.style.cssText = 'padding: 16px 16px 8px; font-weight: 600; color: #6b7280; font-size: 14px; margin-top: 16px;';
    completedHeader.textContent = '‚úÖ Completate';
    container.appendChild(completedHeader);
    
    completedDeliveries.forEach((delivery, index) => {
      const card = document.createElement('div');
      card.className = 'delivery-card completed';
      card.onclick = () => openDelivery(delivery);
      
      card.innerHTML = `
        <div class="delivery-header">
          <div class="delivery-number" style="background: #10b981;">‚úì</div>
          <div class="delivery-status completed">Completato</div>
        </div>
        <div class="customer-name">${delivery.customer}</div>
        <div class="customer-address">${delivery.address}</div>
        ${delivery.phone ? `<div style="font-size: 13px; color: #6b7280;">üìû ${delivery.phone}</div>` : ''}
        <div class="delivery-meta">
          <span>üì¶ ${delivery.products.length} prodotti</span>
          <span>üìÑ ${delivery.name}</span>
        </div>
        <div class="delivery-actions">
          <button class="action-btn btn-secondary" onclick="event.stopPropagation(); printDelivery(${delivery.id})" style="background: #6b7280; color: white;">
            üñ®Ô∏è Stampa
          </button>
          <button class="action-btn btn-secondary" onclick="event.stopPropagation(); openScaricoView(state.deliveries.find(d => d.id === ${delivery.id}))">
            üì§ Visualizza
          </button>
          <button class="action-btn btn-warning" onclick="event.stopPropagation(); handleReso(${delivery.id})" style="background: #f59e0b; color: white;">
            üì¶ Reso
          </button>
        </div>
      `;
      
      container.appendChild(card);
    });
  }
}

// Update stats
function updateStats() {
  const total = state.deliveries.length;
  const completed = state.deliveries.filter(d => d.completed).length;
  const backorders = state.deliveries.filter(d => !d.completed && d.isBackorder).length;
  const remaining = state.deliveries.filter(d => !d.completed && !d.isBackorder).length;
  
  // Aggiorna i contatori esistenti
  document.getElementById('totalDeliveries').textContent = total;
  document.getElementById('completedDeliveries').textContent = completed;
  document.getElementById('remainingDeliveries').textContent = remaining + (backorders > 0 ? ` (+${backorders} residui)` : '');
}

// Get map styles based on POI preferences
function getMapStyles() {
  const styles = [];
  
  // Business (include ristoranti)
  if (!document.getElementById('poiBusiness')?.checked && !document.getElementById('poiRestaurants')?.checked) {
    styles.push({
      featureType: "poi.business",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    });
  }
  
  // Transit
  if (!document.getElementById('poiTransit')?.checked) {
    styles.push({
      featureType: "transit",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    });
  }
  
  // Medical
  if (!document.getElementById('poiMedical')?.checked) {
    styles.push({
      featureType: "poi.medical",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    });
  }
  
  // Parks
  if (!document.getElementById('poiParks')?.checked) {
    styles.push({
      featureType: "poi.park",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    });
  }
  
  // Schools
  if (!document.getElementById('poiSchools')?.checked) {
    styles.push({
      featureType: "poi.school",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    });
  }
  
  // Sempre nascondi questi
  styles.push(
    {
      featureType: "poi.attraction",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    },
    {
      featureType: "poi.government",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    },
    {
      featureType: "poi.place_of_worship",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    },
    {
      featureType: "poi.sports_complex",
      elementType: "labels",
      stylers: [{ visibility: "off" }]
    }
  );
  
  return styles;
}

// Initialize Google Maps
function initMap() {
  state.map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: 46.9480, lng: 7.4474 },
    zoom: 10,
    mapTypeControl: false,
    streetViewControl: true,
    fullscreenControl: false,
    styles: getMapStyles(),
    // Opzioni aggiuntive per una mappa pi√π pulita
    zoomControl: true,
    scaleControl: false,
    rotateControl: false
  });
  
  // Prevent any calls to invalidateSize (Leaflet method)
  state.map.invalidateSize = function() {
    console.warn('‚ö†Ô∏è invalidateSize chiamato ma intercettato - uso Google Maps resize invece');
    google.maps.event.trigger(state.map, 'resize');
  };
  
  state.infoWindow = new google.maps.InfoWindow();
}

// Toggle map controls panel
function toggleMapControls() {
  const content = document.getElementById('mapControlsContent');
  const arrow = document.getElementById('controlsArrow');
  
  if (content.classList.contains('active')) {
    content.classList.remove('active');
    arrow.textContent = '‚ñº';
  } else {
    content.classList.add('active');
    arrow.textContent = '‚ñ≤';
  }
}

// Update map POI visibility
function updateMapPOI() {
  if (state.map) {
    state.map.setOptions({ styles: getMapStyles() });
  }
}

// Update map markers
function updateMap() {
  if (!state.map) {
    console.log('Mappa non inizializzata, skippo updateMap');
    return;
  }
  
  try {
    // Clear existing markers
    if (state.markers && state.markers.length > 0) {
      state.markers.forEach(marker => {
        if (marker && marker.setMap) {
          marker.setMap(null);
        }
      });
    }
    state.markers = [];
  
  const bounds = new google.maps.LatLngBounds();
  
  // Contatore per numerare solo le consegne attive (non completate e non residui)
  let activeDeliveryNumber = 0;
  
  state.deliveries.forEach((delivery, index) => {
    if (delivery.lat && delivery.lng) {
      // DEBUG: Log ogni consegna per vedere i dati
      console.log(`üìç Mappa - ${delivery.name}:`, {
        isBackorder: delivery.isBackorder,
        backorderId: delivery.backorderId,
        isResiduo: delivery.isResiduo,
        state: delivery.state
      });
      
      // Per consegne raggruppate, controlla se TUTTI i documenti sono completati
      let isCompleted = delivery.completed;
      if (delivery.isGrouped && delivery.linkedPickings) {
        isCompleted = delivery.linkedPickings.every(p => 
          p.completed || p.state === 'done' || state.completedDeliveries.has(p.id)
        );
      }
      
      // Verifica se √® un ordine residuo PRIMA di incrementare il numero
      const isOrderResidue = delivery.isBackorder === true || 
                            delivery.isResiduo === true || 
                            (delivery.backorderId !== null && delivery.backorderId !== false && delivery.backorderId !== undefined) || 
                            (delivery.name && delivery.name.includes('/BO'));
      
      // Log dettagliato per debug ordini residui
      if (isOrderResidue) {
        console.log(`üî∂ Ordine RESIDUO rilevato: ${delivery.name}`, {
          isBackorder: delivery.isBackorder,
          isResiduo: delivery.isResiduo,
          backorderId: delivery.backorderId,
          hasBO: delivery.name?.includes('/BO')
        });
      }
      
      // Incrementa il numero solo per consegne attive (non completate e non residui)
      if (!isCompleted && !isOrderResidue) {
        activeDeliveryNumber++;
      }
      
      // Colore diverso per ordini residui
      let markerColor = '#4f46e5';  // Blu default
      let markerLabel = '';
      
      if (isCompleted) {
        markerColor = '#10b981';  // Verde per completati
        markerLabel = '‚úì';  // Check per completati
      } else if (isOrderResidue) {
        markerColor = '#f59e0b';  // Arancione per ordini residui
        markerLabel = 'R';  // R per residui
        console.log(`üî∂ Marker ARANCIONE creato per: ${delivery.name}`);
      } else {
        // Solo le consegne attive hanno il numero progressivo
        markerLabel = String(activeDeliveryNumber);
      }
      
      // Google Maps marker icon
      const markerIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: markerColor,
        fillOpacity: isCompleted ? 0.5 : (isOrderResidue ? 0.7 : 1),  // Verde 50%, Arancione 70%, Blu 100%
        strokeColor: '#FFFFFF',
        strokeWeight: 2,
        scale: 15
      };
      
      const marker = new google.maps.Marker({
        position: { lat: delivery.lat, lng: delivery.lng },
        map: state.map,
        icon: markerIcon,
        label: {
          text: markerLabel,
          color: 'white',
          fontSize: '14px',
          fontWeight: 'bold'
        }
      });
      
      // Info window content - stessa logica per tutti i tipi di ordini
      const infoContent = `
          <div style="min-width: 200px;">
            <b style="font-size: 14px;">${delivery.customer}</b><br>
            <span style="font-size: 12px; color: #6b7280;">${delivery.address}</span><br>
            ${delivery.phone ? `<span style="font-size: 12px; color: #6b7280;">üìû ${delivery.phone}</span><br>` : ''}
            ${delivery.note ? `<div style="margin-top: 8px; padding: 8px; background: #fef3c7; border-radius: 4px; font-size: 12px;">üìù <b>Note:</b> ${delivery.note}</div>` : ''}
            ${isOrderResidue ? `
              <div style="margin-top: 8px; padding: 8px; background: #fee2e2; border-radius: 4px; font-size: 12px; color: #991b1b;">
                <strong>‚ö†Ô∏è Ordine Residuo:</strong> Completato con riserva - Solo visualizzazione
              </div>
            ` : ''}
            ${isCompleted && !isOrderResidue ? `
              <div style="margin-top: 8px; padding: 8px; background: #d1fae5; border-radius: 4px; font-size: 12px; color: #065f46;">
                <strong>‚úÖ Completato:</strong> Solo visualizzazione
              </div>
            ` : ''}
            <div style="display: flex; gap: 4px; margin-top: 8px;">
              <button onclick="navigateTo(${delivery.lat}, ${delivery.lng})" style="flex: 1; padding: 6px 8px; background: #10b981; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                üß≠ Naviga
              </button>
              ${isOrderResidue 
                ? `<button onclick="openScaricoView(state.deliveries[${index}])" style="flex: 1; padding: 6px 8px; background: #f59e0b; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                    üëÅÔ∏è Visualizza
                  </button>`
                : isCompleted 
                  ? `<button onclick="openScaricoView(state.deliveries[${index}])" style="flex: 1; padding: 6px 8px; background: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                      üëÅÔ∏è Visualizza
                    </button>`
                  : `<button onclick="openScaricoView(state.deliveries[${index}])" style="flex: 1; padding: 6px 8px; background: #f59e0b; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                      üì§ Scarica
                    </button>`
              }
            </div>
          </div>
      `;
      
      // Add click listener for info window
      marker.addListener('click', () => {
        state.infoWindow.setContent(infoContent);
        state.infoWindow.open(state.map, marker);
      });
      
      state.markers.push(marker);
      bounds.extend(marker.getPosition());
    }
  });
  
  // Add current position if available
  if (state.currentPosition) {
    // Icona furgoncino per la posizione dell'autista
    const truckPath = 'M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-3-4zM6 18c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm13.5-8.5l1.96 2.5H17V9.5h2.5zM18 18c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z';
    
    const userIcon = {
      path: truckPath,
      fillColor: '#ef4444',
      fillOpacity: 1,
      strokeColor: '#FFFFFF',
      strokeWeight: 1.5,
      scale: 1.5,
      rotation: 0,  // Pu√≤ essere aggiornato con la direzione del movimento
      anchor: new google.maps.Point(12, 12)
    };
    
    const userMarker = new google.maps.Marker({
      position: { lat: state.currentPosition.lat, lng: state.currentPosition.lng },
      map: state.map,
      icon: userIcon,
      title: 'La tua posizione',
      zIndex: 1000  // Assicura che il furgoncino sia sopra gli altri marker
    });
    
    state.markers.push(userMarker);
    bounds.extend(userMarker.getPosition());
  }
  
  // Fit bounds
  if (state.markers.length > 0) {
    state.map.fitBounds(bounds);
  }
  
  } catch (error) {
    console.error('Errore in updateMap:', error);
    showToast('Errore aggiornamento mappa', 'error');
  }
}

// Open delivery details
function openDelivery(delivery) {
  // Show normal delivery modal - PERMETTIAMO L'APERTURA ANCHE PER ORDINI RESIDUI
  state.currentDelivery = delivery;
  
  // Check if modal elements exist
  const modalTitle = document.getElementById('modalTitle');
  const modalCustomer = document.getElementById('modalCustomer');
  const modalAddress = document.getElementById('modalAddress');
  const modalPhone = document.getElementById('modalPhone');
  const modalNotes = document.getElementById('modalNotes');
  const modalProducts = document.getElementById('modalProducts');
  const deliveryModal = document.getElementById('deliveryModal');
  
  if (!modalTitle || !deliveryModal) {
    console.error('Modal elements not found, creating temporary modal');
    // Create a temporary modal if the main one doesn't exist
    const tempModal = document.createElement('div');
    tempModal.className = 'modal active';
    tempModal.innerHTML = `
      <div class="modal-header">
        <div class="modal-title">${delivery.name}</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div class="modal-content">
        <div class="info-section">
          <h3 style="font-size: 16px; margin-bottom: 8px;">üìç Destinatario</h3>
          <div style="font-weight: 600;">${delivery.customer}</div>
          <div style="color: #6b7280; margin-top: 4px;">${delivery.address}</div>
          <div style="color: #6b7280; margin-top: 4px;">${delivery.phone ? 'üìû ' + delivery.phone : 'Telefono non disponibile'}</div>
        </div>
        
        <div class="info-section">
          <h3 style="font-size: 16px; margin-bottom: 8px;">üì¶ Prodotti</h3>
          <div>${delivery.products && delivery.products.length > 0 ? 
            delivery.products.map(p => 
              '<div class="product-item"><div style="display: flex; justify-content: space-between;"><span>' + p.name + '</span><span style="font-weight: 600;">x' + p.qty + '</span></div></div>'
            ).join('') : '<div style="color: #6b7280;">Nessun prodotto specificato</div>'
          }</div>
        </div>
        
        <div class="info-section">
          <h3 style="font-size: 16px; margin-bottom: 8px;">üìù Note</h3>
          <div style="color: #6b7280;">${delivery.note || 'Nessuna nota'}</div>
        </div>
        
        <div style="padding: 16px;">
          <button class="action-btn btn-primary" onclick="navigateTo(${delivery.lat}, ${delivery.lng})" style="width: 100%; margin-bottom: 8px;">
            üß≠ Naviga con Google Maps
          </button>
          <button class="action-btn btn-success" onclick="openScaricoView(state.deliveries.find(d => d.id === ${delivery.id}))" style="width: 100%;">
            üì§ Vai allo Scarico
          </button>
        </div>
      </div>
    `;
    document.body.appendChild(tempModal);
    return;
  }
  
  modalTitle.textContent = delivery.name;
  modalCustomer.textContent = delivery.customer;
  modalAddress.textContent = delivery.address;
  modalPhone.textContent = delivery.phone ? 'üìû ' + delivery.phone : 'Telefono non disponibile';
  modalNotes.textContent = delivery.note || 'Nessuna nota';
  
  // Products
  let productsHtml = '';
  if (delivery.products && delivery.products.length > 0) {
    productsHtml = delivery.products.map(p => 
      `<div class="product-item">
        <div style="display: flex; justify-content: space-between;">
          <span>${p.name}</span>
          <span style="font-weight: 600;">x${p.qty}</span>
        </div>
      </div>`
    ).join('');
  } else {
    productsHtml = '<div style="color: #6b7280;">Nessun prodotto specificato</div>';
  }
  
  modalProducts.innerHTML = productsHtml;
  
  deliveryModal.classList.add('active');
}

// Close modal
function closeModal() {
  document.getElementById('deliveryModal').classList.remove('active');
}

// Navigate
function navigate() {
  if (!state.currentDelivery || !state.currentDelivery.lat) {
    showToast('Coordinate non disponibili', 'error');
    return;
  }
  
  navigateTo(state.currentDelivery.lat, state.currentDelivery.lng);
}

function navigateTo(lat, lng) {
  if (!lat || !lng) {
    showToast('Coordinate non disponibili', 'error');
    return;
  }
  
  const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
  window.open(url, '_blank');
}


// Mark as complete
async function markComplete() {
  if (!state.currentDelivery) return;
  
  // Open signature modal
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚úçÔ∏è Firma per Completamento</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 16px;">
        <div class="signature-container">
          <label style="display: block; margin-bottom: 8px; color: #6b7280; font-weight: 600;">
            Firma del destinatario
          </label>
          <canvas id="signatureCanvas" class="signature-canvas"></canvas>
          <div class="signature-buttons">
            <button class="signature-clear" onclick="clearSignature()">
              üóëÔ∏è Pulisci Firma
            </button>
          </div>
        </div>
        
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; color: #6b7280;">üì∏ Foto prova di consegna (opzionale)</label>
          <input type="file" accept="image/*" capture="camera" id="deliveryPhoto" style="width: 100%; padding: 8px; border: 2px solid #e5e7eb; border-radius: 8px;">
        </div>
        
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; color: #6b7280;">üìù Note consegna (opzionale)</label>
          <textarea id="deliveryNotes" style="width: 100%; padding: 8px; border: 2px solid #e5e7eb; border-radius: 8px; min-height: 80px;" placeholder="Note sulla consegna..."></textarea>
        </div>
        
        <button class="action-btn btn-success" onclick="completeWithSignature()" style="width: 100%;">
          ‚úÖ Completa con Firma
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Initialize signature canvas
  initSignatureCanvas();
}

// Initialize signature canvas
function initSignatureCanvas() {
  const canvas = document.getElementById('signatureCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  let isDrawing = false;
  let lastX = 0;
  let lastY = 0;
  
  // Set canvas size
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  
  // Drawing functions
  function startDrawing(e) {
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    
    if (e.touches) {
      lastX = e.touches[0].clientX - rect.left;
      lastY = e.touches[0].clientY - rect.top;
    } else {
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    }
  }
  
  function draw(e) {
    if (!isDrawing) return;
    e.preventDefault();
    
    const rect = canvas.getBoundingClientRect();
    let currentX, currentY;
    
    if (e.touches) {
      currentX = e.touches[0].clientX - rect.left;
      currentY = e.touches[0].clientY - rect.top;
    } else {
      currentX = e.clientX - rect.left;
      currentY = e.clientY - rect.top;
    }
    
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(currentX, currentY);
    ctx.strokeStyle = '#1f2937';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.stroke();
    
    lastX = currentX;
    lastY = currentY;
  }
  
  function stopDrawing() {
    isDrawing = false;
  }
  
  // Mouse events
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);
  
  // Touch events
  canvas.addEventListener('touchstart', startDrawing);
  canvas.addEventListener('touchmove', draw);
  canvas.addEventListener('touchend', stopDrawing);
}

// Clear signature
function clearSignature() {
  const canvas = document.getElementById('signatureCanvas');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

// Complete with signature
async function completeWithSignature() {
  const canvas = document.getElementById('signatureCanvas');
  // photo non pi√π necessaria - gestita dal nuovo sistema allegati
  const notes = document.getElementById('deliveryNotes').value;
  
  console.log('üìù NOTE INSERITE:', notes || 'NESSUNA NOTA');
  
  // Usa il delivery corretto (potrebbe essere chiamata da scarico o normale)
  const currentDelivery = scaricoState?.currentDelivery || state.currentDelivery;
  if (!currentDelivery) {
    showToast('Errore: nessuna consegna selezionata', 'error');
    return;
  }
  
  // Check if signature is provided
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const hasSignature = imageData.data.some(channel => channel !== 0);
  
  if (!hasSignature) {
    showToast('Per favore aggiungi la firma', 'error');
    return;
  }
  
  showLoading(true);
  showToast('‚è≥ Salvataggio firma e chiusura documento...', 'info');
  
  try {
    // 1. Salva la firma come base64
    const signatureData = canvas.toDataURL('image/png').split(',')[1];
    
    // 2. Crea allegato per la firma
    const signatureAttachmentId = await callOdoo('ir.attachment', 'create', [{
      name: `Firma_${currentDelivery.name}_${new Date().toISOString()}.png`,
      datas: signatureData,
      res_model: 'stock.picking',
      res_id: currentDelivery.id,
      type: 'binary'
    }]);
    console.log('Firma salvata come allegato:', signatureAttachmentId);
    
    // 3. Foto gestita dal nuovo sistema allegati
    // Gli allegati sono gi√† gestiti tramite attachmentManager
    
    // 4. Aggiungi messaggio nel chatter con allegati (ESATTO metodo del pagamento che FUNZIONA)
    const messageHtml = `‚úçÔ∏è CONSEGNA COMPLETATA CON FIRMA<br/>
${notes ? `<strong>üìù Note del driver:</strong> ${notes}<br/>` : '<strong>üìù Note:</strong> Nessuna nota inserita<br/>'}
<strong>üìÖ Data:</strong> ${new Date().toLocaleString('it-IT')}<br/>
<strong>‚úÖ Allegati:</strong> Firma del cliente`;
    
    // Prepara array allegati (solo firma, le foto sono gestite separatamente)
    const attachmentIds = [signatureAttachmentId];
    
    try {
      // USA ESATTAMENTE LO STESSO METODO DEL PAGAMENTO CHE FUNZIONA
      console.log('üì¨ Tentativo di creare messaggio con contenuto:', messageHtml);
      const messageResult = await callOdoo('mail.message', 'create', [{
        model: 'stock.picking',  // NON message_post ma mail.message con model!
        res_id: currentDelivery.id,
        body: messageHtml,
        message_type: 'comment',
        attachment_ids: [[6, false, attachmentIds]]  // Stesso formato del pagamento
      }]);
      console.log('‚úÖ Messaggio salvato nel documento con ID:', messageResult);
      console.log('‚úÖ Contenuto messaggio salvato:', messageHtml);
    } catch (msgError) {
      console.warn('Errore aggiunta messaggio, provo metodo alternativo:', msgError);
      
      // Metodo alternativo: aggiorna l'allegato per collegarlo
      try {
        await callOdoo('ir.attachment', 'write', [[signatureAttachmentId], {
          res_model: 'stock.picking',
          res_id: state.currentDelivery.id,
          description: `Firma consegna${notes ? ` - ${notes}` : ''}`
        }]);
        
        // Aggiungi note direttamente nel picking
        await callOdoo('stock.picking', 'write', [[state.currentDelivery.id], {
          note: `${state.currentDelivery.note || ''}\n\n‚úçÔ∏è CONSEGNA CON FIRMA - ${new Date().toLocaleString('it-IT')}\n${notes ? `Note: ${notes}` : ''}\nFirma e foto allegate`
        }]);
        
        console.log('Note salvate nel documento');
      } catch (altError) {
        console.warn('Impossibile aggiungere note:', altError);
      }
    }
    
    // 5. IMPORTANTE: Valida il picking per chiuderlo in Odoo
    showToast('üì¶ Chiusura documento in Odoo...', 'info');
    try {
      // Prima prova la validazione normale
      const result = await callOdoo('stock.picking', 'button_validate', [[state.currentDelivery.id]]);
      
      // Se ritorna un wizard (per prodotti scaduti), confermalo automaticamente
      if (result && typeof result === 'object' && result.res_model) {
        console.log('üîÑ Wizard rilevato, confermo automaticamente...');
        
        if (result.res_model === 'stock.immediate.transfer' || result.res_model === 'stock.backorder.confirmation') {
          // Conferma il wizard per procedere con prodotti scaduti
          const wizardId = result.res_id;
          await callOdoo(result.res_model, 'process', [[wizardId]]);
          console.log('‚úÖ Wizard confermato, picking validato');
        } else if (result.res_model === 'stock.overprocessed.transfer') {
          // Gestisci over-processing
          const wizardId = result.res_id;
          await callOdoo(result.res_model, 'action_confirm', [[wizardId]]);
          console.log('‚úÖ Over-processing confermato');
        }
      }
      
      console.log('‚úÖ Picking validato e chiuso in Odoo');
      
      // Aggiorna stato locale
      state.currentDelivery.state = 'done';
      state.currentDelivery.completed = true;
      
      // Trova e aggiorna nell'array delle consegne
      const deliveryIndex = state.deliveries.findIndex(d => d.id === state.currentDelivery.id);
      if (deliveryIndex !== -1) {
        state.deliveries[deliveryIndex].state = 'done';
        state.deliveries[deliveryIndex].completed = true;
      }
      
      showToast('‚úÖ Consegna completata e chiusa con firma!', 'success');
      
      // Ricalcola ETA per le consegne rimanenti
      await recalculateETAsAfterDelivery();
    } catch (validationError) {
      console.warn('‚ö†Ô∏è Errore validazione:', validationError);
      
      // Se l'errore √® dovuto a prodotti scaduti, prova a forzare
      if (validationError.message && (validationError.message.includes('expired') || 
          validationError.message.includes('scadut') || 
          validationError.message.includes('lot'))) {
        console.log('üîÑ Tentativo di forzare validazione nonostante prodotti scaduti...');
        
        try {
          // Prima setta il picking come done forzatamente
          await callOdoo('stock.picking', 'write', [[state.currentDelivery.id], {
            state: 'done',
            date_done: new Date().toISOString()
          }]);
          
          // Poi prova action_done se esiste
          try {
            await callOdoo('stock.picking', 'action_done', [[state.currentDelivery.id]]);
          } catch (e) {
            console.log('action_done non disponibile');
          }
          
          // Aggiorna stato locale comunque
          state.currentDelivery.state = 'done';
          state.currentDelivery.completed = true;
          
          const deliveryIndex = state.deliveries.findIndex(d => d.id === state.currentDelivery.id);
          if (deliveryIndex !== -1) {
            state.deliveries[deliveryIndex].state = 'done';
            state.deliveries[deliveryIndex].completed = true;
          }
          
          showToast('‚úÖ Consegna completata (prodotti scaduti ignorati)', 'success');
          
          // Ricalcola ETA per le consegne rimanenti
          await recalculateETAsAfterDelivery();
        } catch (forceError) {
          console.error('Impossibile forzare:', forceError);
          showToast('‚ö†Ô∏è Consegna salvata ma richiede validazione manuale in Odoo', 'warning');
        }
      } else {
        showToast('‚ö†Ô∏è Consegna salvata ma richiede validazione manuale in Odoo', 'warning');
      }
    }
    
    // 6. Marca come completato localmente e salva stato
    state.completedDeliveries.add(state.currentDelivery.id);
    state.currentDelivery.signature = signatureData;
    state.currentDelivery.deliveryNotes = notes;
    
    // Salva in localStorage
    try {
      const stateToSave = {
        completedDeliveries: Array.from(state.completedDeliveries)
      };
      localStorage.setItem('deliveryAppState', JSON.stringify(stateToSave));
    } catch (saveError) {
      console.warn('Impossibile salvare stato:', saveError);
    }
    
    // Close all modals
    document.querySelectorAll('.modal').forEach(m => m.remove());
    renderDeliveries();
    updateStats();
    
  } catch (error) {
    console.error('Errore completamento:', error);
    showToast('Errore: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Switch view
function switchView(view) {
  // Remove active class from all nav items
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.remove('active');
  });
  
  // Add active class to the clicked nav item if possible
  if (event && event.target) {
    const navItem = event.target.closest('.nav-item');
    if (navItem) {
      navItem.classList.add('active');
    }
  }
  
  const statsContainer = document.getElementById('statsContainer');
  const listView = document.getElementById('listView');
  const mapView = document.getElementById('mapView');
  
  // Check if elements exist before accessing them
  if (!statsContainer || !listView || !mapView) {
    console.error('View elements not found');
    return;
  }
  
  if (view === 'map') {
    statsContainer.style.display = 'none';
    listView.style.display = 'none';
    mapView.style.display = 'block';
    
    setTimeout(() => {
      if (state.map) {
        try {
          // Trigger resize event for Google Maps
          if (google && google.maps && google.maps.event) {
            google.maps.event.trigger(state.map, 'resize');
          }
          updateMap();
        } catch (error) {
          console.error('Errore aggiornamento mappa:', error);
          // Reinizializza la mappa se c'√® un problema
          try {
            initMap();
            updateMap();
          } catch (reinitError) {
            console.error('Errore reinizializzazione mappa:', reinitError);
          }
        }
      } else {
        // Se la mappa non esiste, prova a inizializzarla
        console.log('Mappa non trovata, inizializzo...');
        try {
          initMap();
          updateMap();
        } catch (initError) {
          console.error('Errore inizializzazione mappa:', initError);
        }
      }
    }, 100);
  } else {
    statsContainer.style.display = 'grid';
    listView.style.display = 'block';
    mapView.style.display = 'none';
  }
}

// Reload data
async function reloadData() {
  showLoading(true);
  try {
    await loadDeliveries();
    showToast(`Aggiornato! ${state.deliveries.length} consegne`, 'success');
  } catch (error) {
    showToast('Errore aggiornamento: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Optimize delivery route - apre il modal interattivo
async function optimizeRoute() {
  // Debug: mostra tutte le consegne
  console.log('üì¶ Totale consegne:', state.deliveries.length);
  console.log('Dettaglio consegne:', state.deliveries.map(d => ({
    name: d.name,
    customer: d.customer,
    state: d.state,
    completed: d.completed,
    isBackorder: d.isBackorder
  })));
  
  // Filtra solo le consegne attive (non completate)
  const activeDeliveries = state.deliveries.filter(d => 
    d.state !== 'done' && !d.completed && !d.isBackorder
  );
  
  console.log('‚úÖ Consegne DA FARE:', activeDeliveries.length);
  console.log('Consegne attive:', activeDeliveries.map(d => d.customer));
  
  if (activeDeliveries.length < 1) {
    showToast('Nessuna consegna da organizzare', 'info');
    return;
  }
  
  if (activeDeliveries.length > 25) {
    showToast('Troppi indirizzi! Massimo 25', 'warning');
    return;
  }
  
  // Mostra subito il modal con le consegne attuali
  showRouteOrganizerModal(activeDeliveries);
}

// Ottimizza con Google AI partendo dalla posizione attuale
async function optimizeWithGoogle() {
  const deliveries = state.tempDeliveryOrder || state.deliveries.filter(d => 
    d.state !== 'done' && !d.completed && !d.isBackorder
  );
  
  if (deliveries.length < 2) {
    showToast('Servono almeno 2 consegne per ottimizzare', 'info');
    return;
  }
  
  showLoading(true);
  showToast('üìç Ottengo posizione GPS...', 'info');
  
  try {
    // Ottieni posizione attuale dell'autista
    const currentPosition = await getCurrentPosition();
    
    showToast('üéØ Calcolo percorso ottimale...', 'info');
    
    // Prepara i waypoint per Google Routes API
    const waypoints = deliveries.map(delivery => {
      if (delivery.lat && delivery.lng) {
        return {
          location: {
            latLng: {
              latitude: delivery.lat,
              longitude: delivery.lng
            }
          }
        };
      }
      return { address: delivery.address };
    });
    
    // API Key
    const API_KEY = 'AIzaSyDQbkXsAyNQs0NypjDgTGA_SUxFxJWmijk';
    
    // Chiamata all'API con origine dalla posizione attuale
    const response = await fetch(`https://routes.googleapis.com/directions/v2:computeRoutes`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': API_KEY,
        'X-Goog-FieldMask': 'routes.optimizedIntermediateWaypointIndex,routes.distanceMeters,routes.duration'
      },
      body: JSON.stringify({
        origin: {
          location: {
            latLng: {
              latitude: currentPosition.coords.latitude,
              longitude: currentPosition.coords.longitude
            }
          }
        },
        destination: waypoints[waypoints.length - 1], // Ultima consegna
        intermediates: waypoints.slice(0, -1), // Tutte tranne l'ultima
        travelMode: 'DRIVE',
        optimizeWaypointOrder: true,
        languageCode: 'it-IT',
        units: 'METRIC'
      })
    });
    
    if (!response.ok) {
      throw new Error('Errore nella chiamata API');
    }
    
    const data = await response.json();
    
    if (!data.routes || data.routes.length === 0) {
      throw new Error('Nessun percorso trovato');
    }
    
    const optimizedRoute = data.routes[0];
    const optimizedOrder = optimizedRoute.optimizedIntermediateWaypointIndex || [];
    
    // Riordina le consegne
    const reorderedDeliveries = [];
    
    // Se c'√® ottimizzazione, riordina
    if (optimizedOrder && optimizedOrder.length > 0) {
      // Crea array con tutte le consegne intermedie (esclusa l'ultima che √® la destinazione)
      const intermediates = deliveries.slice(0, -1);
      
      // Aggiungi nell'ordine ottimizzato
      optimizedOrder.forEach(index => {
        if (index < intermediates.length) {
          reorderedDeliveries.push(intermediates[index]);
        }
      });
      
      // Aggiungi l'ultima (destinazione)
      reorderedDeliveries.push(deliveries[deliveries.length - 1]);
    } else {
      // Se non c'√® ottimizzazione, mantieni l'ordine originale
      reorderedDeliveries.push(...deliveries);
    }
    
    // Aggiorna il modal con l'ordine ottimizzato
    updateModalWithOptimizedOrder(reorderedDeliveries);
    
    const totalDistance = (optimizedRoute.distanceMeters / 1000).toFixed(1);
    const totalTime = Math.round(optimizedRoute.duration.slice(0, -1) / 60);
    
    showToast(`‚úÖ Ottimizzato! ${totalDistance}km - ${totalTime}min`, 'success');
    
  } catch (error) {
    console.error('Errore ottimizzazione:', error);
    showToast('‚ùå Errore: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Calcola ETA per ogni consegna con 15 minuti per fermata
async function calculateETAsForDeliveries(orderedDeliveries = null) {
  try {
    // Usa le consegne ordinate o quelle attive
    const deliveries = orderedDeliveries || state.deliveries.filter(d => 
      d.state !== 'done' && !d.completed && !d.isBackorder
    );
    
    if (deliveries.length === 0) return;
    
    console.log('‚è∞ Calcolo ETA per', deliveries.length, 'consegne...');
    
    // Ottieni posizione attuale
    const currentPosition = await getCurrentPosition();
    
    // Prepara waypoints per Google Routes API
    const waypoints = deliveries.map(delivery => {
      if (delivery.lat && delivery.lng) {
        return {
          location: {
            latLng: {
              latitude: delivery.lat,
              longitude: delivery.lng
            }
          }
        };
      }
      return { address: delivery.address };
    });
    
    if (waypoints.length === 0) return;
    
    const API_KEY = 'AIzaSyDQbkXsAyNQs0NypjDgTGA_SUxFxJWmijk';
    
    // Calcola tempi di percorrenza tra ogni tappa
    const response = await fetch(`https://routes.googleapis.com/distanceMatrix/v2:computeRouteMatrix`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': API_KEY,
        'X-Goog-FieldMask': 'originIndex,destinationIndex,duration,distanceMeters'
      },
      body: JSON.stringify({
        origins: [
          {
            waypoint: {
              location: {
                latLng: {
                  latitude: currentPosition.coords.latitude,
                  longitude: currentPosition.coords.longitude
                }
              }
            }
          },
          ...waypoints.slice(0, -1).map(w => ({ waypoint: w }))
        ],
        destinations: waypoints.map(w => ({ waypoint: w })),
        travelMode: 'DRIVE',
        routingPreference: 'TRAFFIC_AWARE'
      })
    });
    
    if (!response.ok) {
      throw new Error('Errore calcolo tempi');
    }
    
    const data = await response.json();
    
    // Calcola ETA per ogni consegna
    const now = new Date();
    let accumulatedTime = 0; // in minuti
    const STOP_TIME = 15; // 15 minuti per fermata
    
    // Se non c'√® un orario di inizio giro, usa l'ora attuale
    if (!state.routeStartTime) {
      state.routeStartTime = now;
    }
    
    deliveries.forEach((delivery, index) => {
      // Trova il tempo di viaggio dalla posizione precedente
      let travelTime = 0;
      
      if (index === 0) {
        // Prima consegna: dalla posizione attuale
        const matrixElement = data.find(e => 
          e.originIndex === 0 && e.destinationIndex === index
        );
        if (matrixElement && matrixElement.duration) {
          travelTime = Math.ceil(parseInt(matrixElement.duration) / 60); // converti in minuti
        }
      } else {
        // Consegne successive: dalla consegna precedente
        const matrixElement = data.find(e => 
          e.originIndex === index && e.destinationIndex === index
        );
        if (matrixElement && matrixElement.duration) {
          travelTime = Math.ceil(parseInt(matrixElement.duration) / 60);
        }
      }
      
      // Se non abbiamo dati precisi, stima 10 minuti di viaggio
      if (!travelTime) {
        travelTime = 10;
      }
      
      // Accumula tempo di viaggio
      accumulatedTime += travelTime;
      
      // Calcola ETA
      const eta = new Date(state.routeStartTime);
      eta.setMinutes(eta.getMinutes() + accumulatedTime);
      
      // Memorizza ETA
      state.deliveryETAs[delivery.id] = {
        eta: eta,
        etaString: eta.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }),
        travelTime: travelTime,
        accumulatedTime: accumulatedTime
      };
      
      // Debug: verifica cosa sta salvando
      console.log(`üìç ${delivery.customer}: ETA ${state.deliveryETAs[delivery.id].etaString} (+${travelTime} min viaggio)`);
      console.log(`   Date object: ${eta.toString()}`);
      console.log(`   Hours: ${eta.getHours()}, Minutes: ${eta.getMinutes()}`);
      
      // Aggiungi tempo di sosta per la prossima consegna
      accumulatedTime += STOP_TIME;
    });
    
    // Aggiorna UI se siamo nella vista lista
    if (document.getElementById('deliveriesContainer')) {
      updateDeliveryList();
    }
    
    console.log('‚úÖ ETA calcolati per tutte le consegne');
    return state.deliveryETAs;
    
  } catch (error) {
    console.error('Errore calcolo ETA:', error);
    // Fallback: stima semplice di 25 minuti per consegna
    const now = new Date();
    let accumulatedTime = 0;
    
    (orderedDeliveries || state.deliveries.filter(d => 
      d.state !== 'done' && !d.completed && !d.isBackorder
    )).forEach((delivery, index) => {
      accumulatedTime += 25; // 10 min viaggio + 15 min sosta
      const eta = new Date(now);
      eta.setMinutes(eta.getMinutes() + accumulatedTime);
      
      state.deliveryETAs[delivery.id] = {
        eta: eta,
        etaString: eta.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }),
        travelTime: 10,
        accumulatedTime: accumulatedTime
      };
    });
  }
}

// Aggiorna scheduled_date in Odoo con l'ETA calcolato (solo orario, mantiene data)
async function updateOdooScheduledDate(deliveryId) {
  try {
    if (!state.deliveryETAs[deliveryId]) return;
    
    // Trova la consegna per prendere la data originale
    const delivery = state.deliveries.find(d => d.id === deliveryId);
    if (!delivery || !delivery.scheduledDate) return;
    
    const etaData = state.deliveryETAs[deliveryId];
    
    // Prendi la data originale dal scheduled_date esistente
    const originalDate = new Date(delivery.scheduledDate);
    const year = originalDate.getFullYear();
    const month = originalDate.getMonth();
    const day = originalDate.getDate();
    
    // SOLUZIONE SEMPLICE: sottrai 2 ore che vengono aggiunte erroneamente
    const etaDate = new Date(etaData.eta);
    
    // Sottrai 2 ore (7200000 millisecondi)
    const correctedDate = new Date(etaDate.getTime() - (2 * 60 * 60 * 1000));
    
    // Prendi la data originale e combina con l'orario corretto
    const yearStr = originalDate.getFullYear();
    const monthStr = String(originalDate.getMonth() + 1).padStart(2, '0');
    const dayStr = String(originalDate.getDate()).padStart(2, '0');
    
    // Usa l'orario corretto (dopo aver sottratto 2 ore)
    const hoursStr = String(correctedDate.getHours()).padStart(2, '0');
    const minutesStr = String(correctedDate.getMinutes()).padStart(2, '0');
    const secondsStr = '00';
    
    const odooDateTime = `${yearStr}-${monthStr}-${dayStr} ${hoursStr}:${minutesStr}:${secondsStr}`;
    
    console.log(`üîÑ Aggiorno orario per ${delivery.customer}`);
    console.log(`   Orario visualizzato nell'app: ${etaData.etaString}`);
    console.log(`   Orario corretto per Odoo (-2h): ${hoursStr}:${minutesStr}`);
    console.log(`   Data+Ora finale per Odoo: ${odooDateTime}`);
    
    await callOdoo('stock.picking', 'write', [
      [deliveryId],
      {
        scheduled_date: odooDateTime
      }
    ]);
    
    console.log('‚úÖ Orario aggiornato in Odoo (mantenuta la data)');
  } catch (error) {
    console.error('Errore aggiornamento scheduled_date:', error);
  }
}

// Ricalcola ETA dopo ogni chiusura consegna
async function recalculateETAsAfterDelivery() {
  try {
    console.log('üîÑ Ricalcolo ETA dopo chiusura consegna...');
    
    // Resetta l'orario di inizio al momento attuale
    state.routeStartTime = new Date();
    
    // Ricalcola per le consegne rimanenti
    await calculateETAsForDeliveries();
    
    // Aggiorna tutti gli scheduled_date in Odoo
    const activeDeliveries = state.deliveries.filter(d => 
      d.state !== 'done' && !d.completed && !d.isBackorder
    );
    
    for (const delivery of activeDeliveries) {
      await updateOdooScheduledDate(delivery.id);
    }
    
    showToast('‚è∞ Orari di arrivo aggiornati', 'info');
  } catch (error) {
    console.error('Errore ricalcolo ETA:', error);
  }
}

// Ottieni posizione GPS attuale
function getCurrentPosition() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocalizzazione non supportata'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      position => {
        console.log('üìç Posizione GPS ottenuta:', position.coords);
        resolve(position);
      },
      error => {
        console.warn('‚ö†Ô∏è GPS non disponibile, uso posizione di default');
        // Se non riesce, usa la prima consegna come punto di partenza
        const firstDelivery = state.deliveries.find(d => d.lat && d.lng);
        if (firstDelivery) {
          resolve({
            coords: {
              latitude: firstDelivery.lat,
              longitude: firstDelivery.lng
            }
          });
        } else {
          // Altrimenti usa Roma come default
          resolve({
            coords: {
              latitude: 41.9028,
              longitude: 12.4964
            }
          });
        }
      },
      {
        enableHighAccuracy: false, // Cambiato a false per velocizzare
        timeout: 5000, // Ridotto timeout
        maximumAge: 30000 // Accetta posizione cached fino a 30 secondi
      }
    );
  });
}

// Mostra modal organizzatore percorso con drag & drop
function showRouteOrganizerModal(deliveries) {
  // Salva ordine temporaneo
  state.tempDeliveryOrder = [...deliveries];
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px; max-height: 85vh; overflow-y: auto;">
      <div class="modal-header">
        <div class="modal-title">üéØ Organizza Percorso</div>
        <div class="modal-close" onclick="closeRouteOrganizer()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        <!-- Bottone Ottimizza con AI -->
        <button onclick="optimizeWithGoogle()" style="width: 100%; padding: 14px; background: #4f46e5; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
          <span style="font-size: 20px;">ü§ñ</span>
          Ottimizza con AI
        </button>
        
        <div style="font-size: 14px; color: #6b7280; text-align: center; margin-bottom: 16px;">
          ‚ÜïÔ∏è Trascina per riordinare manualmente
        </div>
        
        <!-- Container per drag & drop -->
        <div id="sortableDeliveries" style="display: flex; flex-direction: column; gap: 8px;">
          ${deliveries.map((delivery, index) => `
            <div class="draggable-item" 
                 draggable="true" 
                 data-delivery-id="${delivery.id}"
                 data-index="${index}"
                 style="display: flex; align-items: center; padding: 12px; background: white; border: 2px solid #e5e7eb; border-radius: 8px; cursor: move; transition: all 0.2s;">
              <div style="width: 32px; height: 32px; background: #4f46e5; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 12px;">
                <span class="delivery-number">${index + 1}</span>
              </div>
              <div style="margin-right: 12px; font-size: 20px; color: #9ca3af;">
                ‚â°
              </div>
              <div style="flex: 1;">
                <div style="font-weight: 600; color: #1f2937;">${delivery.customer}</div>
                <div style="font-size: 12px; color: #6b7280;">${delivery.address}</div>
                ${delivery.products ? `<div style="font-size: 11px; color: #9ca3af;">üì¶ ${delivery.products.length} prodotti</div>` : ''}
              </div>
            </div>
          `).join('')}
        </div>
        
        <!-- Info distanza e tempo (aggiornate dopo ottimizzazione) -->
        <div id="routeInfo" style="display: none; background: #f3f4f6; padding: 12px; border-radius: 8px; margin-top: 16px; text-align: center;">
          <div style="display: flex; justify-content: space-around;">
            <div>
              <div id="totalDistance" style="font-size: 20px; font-weight: bold; color: #059669;">-</div>
              <div style="font-size: 12px; color: #6b7280;">Distanza totale</div>
            </div>
            <div>
              <div id="totalTime" style="font-size: 20px; font-weight: bold; color: #059669;">-</div>
              <div style="font-size: 12px; color: #6b7280;">Tempo stimato</div>
            </div>
          </div>
        </div>
        
        <!-- Bottoni Applica e Annulla -->
        <div style="display: flex; gap: 8px; margin-top: 20px;">
          <button onclick="applyRouteOrder()" style="flex: 1; padding: 14px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
            ‚úÖ Applica
          </button>
          <button onclick="closeRouteOrganizer()" style="flex: 1; padding: 14px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
            ‚ùå Annulla
          </button>
        </div>
        
        <!-- Bottone mostra su mappa -->
        <button onclick="showRouteOnMap()" style="width: 100%; padding: 12px; margin-top: 8px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
          üó∫Ô∏è Mostra Percorso su Mappa
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Inizializza drag & drop
  initDragAndDrop();
}

// Inizializza drag & drop (con supporto touch per tablet)
function initDragAndDrop() {
  const container = document.getElementById('sortableDeliveries');
  if (!container) return;
  
  let draggedElement = null;
  let touchItem = null;
  let placeholder = null;
  
  // --- EVENTI MOUSE (per desktop) ---
  container.addEventListener('dragstart', (e) => {
    if (e.target.classList.contains('draggable-item')) {
      draggedElement = e.target;
      e.target.style.opacity = '0.5';
      e.dataTransfer.effectAllowed = 'move';
    }
  });
  
  container.addEventListener('dragend', (e) => {
    if (e.target.classList.contains('draggable-item')) {
      e.target.style.opacity = '';
    }
  });
  
  container.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const afterElement = getDragAfterElement(container, e.clientY);
    if (afterElement == null) {
      container.appendChild(draggedElement);
    } else {
      container.insertBefore(draggedElement, afterElement);
    }
  });
  
  container.addEventListener('drop', (e) => {
    e.preventDefault();
    updateDeliveryNumbers();
    updateTempOrder();
  });
  
  // --- EVENTI TOUCH (per tablet/mobile) ---
  const items = container.querySelectorAll('.draggable-item');
  
  items.forEach(item => {
    // Aggiungi listener per touch
    item.addEventListener('touchstart', handleTouchStart, { passive: false });
    item.addEventListener('touchmove', handleTouchMove, { passive: false });
    item.addEventListener('touchend', handleTouchEnd, { passive: false });
  });
  
  function handleTouchStart(e) {
    // Previeni scroll della pagina
    e.preventDefault();
    
    touchItem = e.currentTarget;
    
    // Crea un placeholder per mantenere lo spazio
    placeholder = touchItem.cloneNode(true);
    placeholder.style.opacity = '0.3';
    placeholder.style.background = '#f3f4f6';
    placeholder.classList.add('placeholder');
    
    // Inserisci il placeholder
    touchItem.parentNode.insertBefore(placeholder, touchItem.nextSibling);
    
    // Stile per l'elemento trascinato
    touchItem.style.position = 'fixed';
    touchItem.style.zIndex = '9999';
    touchItem.style.opacity = '0.8';
    touchItem.style.transform = 'scale(1.05) rotate(2deg)';
    touchItem.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
    touchItem.style.pointerEvents = 'none';
    
    // Posiziona l'elemento sotto il dito
    const touch = e.touches[0];
    touchItem.style.left = (touch.clientX - touchItem.offsetWidth / 2) + 'px';
    touchItem.style.top = (touch.clientY - touchItem.offsetHeight / 2) + 'px';
    
    // Aggiungi classe per identificarlo
    touchItem.classList.add('dragging-touch');
  }
  
  function handleTouchMove(e) {
    if (!touchItem) return;
    e.preventDefault();
    
    const touch = e.touches[0];
    
    // Muovi l'elemento con il dito
    touchItem.style.left = (touch.clientX - touchItem.offsetWidth / 2) + 'px';
    touchItem.style.top = (touch.clientY - touchItem.offsetHeight / 2) + 'px';
    
    // Trova l'elemento sotto il punto di touch
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (elementBelow && elementBelow.classList.contains('draggable-item') && 
        elementBelow !== placeholder && elementBelow !== touchItem) {
      
      // Determina se inserire prima o dopo
      const rect = elementBelow.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      
      if (touch.clientY < midpoint) {
        elementBelow.parentNode.insertBefore(placeholder, elementBelow);
      } else {
        elementBelow.parentNode.insertBefore(placeholder, elementBelow.nextSibling);
      }
    }
  }
  
  function handleTouchEnd(e) {
    if (!touchItem || !placeholder) return;
    e.preventDefault();
    
    // Ripristina lo stile
    touchItem.style.position = '';
    touchItem.style.zIndex = '';
    touchItem.style.opacity = '';
    touchItem.style.transform = '';
    touchItem.style.boxShadow = '';
    touchItem.style.pointerEvents = '';
    touchItem.style.left = '';
    touchItem.style.top = '';
    touchItem.classList.remove('dragging-touch');
    
    // Sostituisci il placeholder con l'elemento reale
    if (placeholder && placeholder.parentNode) {
      placeholder.parentNode.replaceChild(touchItem, placeholder);
    }
    
    // Aggiorna numeri e ordine
    updateDeliveryNumbers();
    updateTempOrder();
    
    // Reset
    touchItem = null;
    placeholder = null;
  }
}

// Trova elemento dopo il quale inserire
function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.draggable-item:not(.dragging)')];
  
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Aggiorna i numeri dopo drag & drop
function updateDeliveryNumbers() {
  const items = document.querySelectorAll('.draggable-item');
  items.forEach((item, index) => {
    const numberSpan = item.querySelector('.delivery-number');
    if (numberSpan) {
      numberSpan.textContent = index + 1;
    }
  });
}

// Aggiorna ordine temporaneo
function updateTempOrder() {
  const items = document.querySelectorAll('.draggable-item');
  const newOrder = [];
  
  items.forEach(item => {
    const deliveryId = parseInt(item.dataset.deliveryId);
    const delivery = state.tempDeliveryOrder.find(d => d.id === deliveryId);
    if (delivery) {
      newOrder.push(delivery);
    }
  });
  
  state.tempDeliveryOrder = newOrder;
}

// Aggiorna modal con ordine ottimizzato
function updateModalWithOptimizedOrder(optimizedDeliveries) {
  const container = document.getElementById('sortableDeliveries');
  if (!container) return;
  
  state.tempDeliveryOrder = [...optimizedDeliveries];
  
  container.innerHTML = optimizedDeliveries.map((delivery, index) => `
    <div class="draggable-item" 
         draggable="true" 
         data-delivery-id="${delivery.id}"
         data-index="${index}"
         style="display: flex; align-items: center; padding: 12px; background: #d1fae5; border: 2px solid #10b981; border-radius: 8px; cursor: move; transition: all 0.2s;">
      <div style="width: 32px; height: 32px; background: #10b981; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 12px;">
        <span class="delivery-number">${index + 1}</span>
      </div>
      <div style="margin-right: 12px; font-size: 20px; color: #059669;">
        ‚â°
      </div>
      <div style="flex: 1;">
        <div style="font-weight: 600; color: #1f2937;">${delivery.customer}</div>
        <div style="font-size: 12px; color: #6b7280;">${delivery.address}</div>
        ${delivery.products ? `<div style="font-size: 11px; color: #9ca3af;">üì¶ ${delivery.products.length} prodotti</div>` : ''}
      </div>
    </div>
  `).join('');
  
  // Reinizializza drag & drop
  initDragAndDrop();
}

// Chiudi organizzatore
function closeRouteOrganizer() {
  document.querySelectorAll('.modal').forEach(m => m.remove());
  state.tempDeliveryOrder = null;
}

// Applica l'ordine del percorso
function applyRouteOrder() {
  if (!state.tempDeliveryOrder) {
    showToast('Errore: nessun ordine da applicare', 'error');
    return;
  }
  
  // Riorganizza l'array delle consegne
  const otherDeliveries = state.deliveries.filter(d => 
    !state.tempDeliveryOrder.some(temp => temp.id === d.id)
  );
  
  state.deliveries = [...state.tempDeliveryOrder, ...otherDeliveries];
  
  // Aggiorna la vista
  renderDeliveries();
  updateStats();
  
  // Chiudi il modal
  closeRouteOrganizer();
  
  showToast('‚úÖ Percorso applicato!', 'success');
  
  // Se siamo nella vista mappa, aggiorna e mostra il percorso
  if (document.getElementById('mapView').style.display !== 'none') {
    updateMap();
    drawRouteOnMap();
  }
}

// Mostra percorso sulla mappa
async function showRouteOnMap() {
  // Chiudi modal
  closeRouteOrganizer();
  
  // Passa alla vista mappa
  switchView('map');
  
  // Aspetta che la mappa sia pronta
  setTimeout(() => {
    drawRouteOnMap();
  }, 500);
}

// Disegna il percorso sulla mappa
async function drawRouteOnMap() {
  if (!state.map) return;
  
  const deliveries = state.tempDeliveryOrder || state.deliveries.filter(d => 
    d.state !== 'done' && !d.completed && !d.isBackorder
  );
  
  if (deliveries.length < 2) return;
  
  showToast('üìç Disegno percorso sulla mappa...', 'info');
  
  try {
    // Ottieni posizione attuale
    const currentPosition = await getCurrentPosition();
    
    // Prepara waypoints
    const waypoints = deliveries.map(d => {
      if (d.lat && d.lng) {
        return { location: { lat: d.lat, lng: d.lng } };
      }
      return { location: d.address };
    });
    
    // Se c'√® gi√† un percorso, rimuovilo
    if (state.directionsRenderer) {
      state.directionsRenderer.setMap(null);
    }
    
    // Crea nuovo renderer per il percorso
    state.directionsRenderer = new google.maps.DirectionsRenderer({
      map: state.map,
      polylineOptions: {
        strokeColor: '#4285F4', // Blu Google
        strokeOpacity: 0.8,
        strokeWeight: 5
      },
      suppressMarkers: false // Mostra i marker A, B, C, etc.
    });
    
    // Servizio directions
    const directionsService = new google.maps.DirectionsService();
    
    // Richiesta percorso
    const request = {
      origin: {
        lat: currentPosition.coords.latitude,
        lng: currentPosition.coords.longitude
      },
      destination: waypoints[waypoints.length - 1].location,
      waypoints: waypoints.slice(0, -1).map(w => ({
        location: w.location,
        stopover: true
      })),
      optimizeWaypoints: false, // Non ottimizzare, usa l'ordine attuale
      travelMode: google.maps.TravelMode.DRIVING,
      unitSystem: google.maps.UnitSystem.METRIC
    };
    
    // Calcola e mostra il percorso
    directionsService.route(request, (result, status) => {
      if (status === 'OK') {
        state.directionsRenderer.setDirections(result);
        
        // Calcola info totali
        let totalDistance = 0;
        let totalTime = 0;
        
        result.routes[0].legs.forEach(leg => {
          totalDistance += leg.distance.value;
          totalTime += leg.duration.value;
        });
        
        const distanceKm = (totalDistance / 1000).toFixed(1);
        const timeMin = Math.round(totalTime / 60);
        
        showToast(`üìç Percorso: ${distanceKm}km - ${timeMin}min`, 'success');
        
        // Aggiusta zoom per vedere tutto il percorso
        const bounds = result.routes[0].bounds;
        state.map.fitBounds(bounds);
        
      } else {
        console.error('Errore calcolo percorso:', status);
        showToast('‚ùå Impossibile calcolare il percorso', 'error');
      }
    });
    
  } catch (error) {
    console.error('Errore disegno percorso:', error);
    showToast('‚ùå Errore: ' + error.message, 'error');
  }
}

// Start GPS tracking
function startGPS() {
  if ('geolocation' in navigator) {
    navigator.geolocation.watchPosition(
      position => {
        state.currentPosition = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };
        console.log('üìç Posizione aggiornata:', state.currentPosition);
      },
      error => console.warn('GPS error:', error),
      { 
        enableHighAccuracy: true,
        maximumAge: 10000,
        timeout: 5000
      }
    );
  }
}

// Show loading
function showLoading(show) {
  document.getElementById('loading').classList.toggle('active', show);
}

// Show toast
function showToast(message, type = 'info') {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.classList.add('show');
  
  if (type === 'error') {
    toast.style.background = '#ef4444';
  } else if (type === 'success') {
    toast.style.background = '#10b981';
  } else if (type === 'warning') {
    toast.style.background = '#f59e0b';
  } else {
    toast.style.background = '#1f2937';
  }
  
  setTimeout(() => {
    toast.classList.remove('show');
  }, 3000);
}

// ========== SCARICO VIEW FUNCTIONS ==========
let scaricoState = {
  currentDelivery: null,
  scaricoProducts: []
};

// Open scarico from modal
function openScaricoFromModal() {
  if (state.currentDelivery) {
    closeModal();
    openScaricoView(state.currentDelivery);
  }
}

// Open Scarico View
async function openScaricoView(delivery) {
  showLoading(true);
  
  try {
    scaricoState.currentDelivery = delivery;
    
    // Verifica se √® un ordine residuo per mostrarlo in modo speciale
    const isBackorder = delivery.isBackorder || delivery.isResiduo;
    
    // Se √® una consegna raggruppata, controlla se TUTTI i documenti sono completati
    let isCompleted = false;
    if (delivery.isGrouped) {
      // Per consegne raggruppate, tutti i documenti devono essere completati
      isCompleted = delivery.linkedPickings.every(p => 
        p.state === 'done' || p.completed === true || state.completedDeliveries.has(p.id)
      );
      console.log('Consegna raggruppata - Stati:', delivery.linkedPickings.map(p => ({
        name: p.name, 
        completed: p.state === 'done' || p.completed || state.completedDeliveries.has(p.id)
      })));
    } else {
      // Singola consegna
      isCompleted = delivery.state === 'done' || 
                   delivery.completed === true || 
                   state.completedDeliveries.has(delivery.id);
    }
    
    // Load products - per consegne raggruppate carica da tutti i documenti
    if (delivery.isGrouped) {
      // Carica prodotti da tutti i documenti raggruppati
      scaricoState.scaricoProducts = [];
      for (const picking of delivery.linkedPickings) {
        await loadScaricoProducts(picking.id, true); // true = append mode
      }
    } else {
      // Carica prodotti singola consegna
      await loadScaricoProducts(delivery.id);
    }
    
    // Update header con indicatore se completata e/o raggruppata
    let headerText = `Scarico ${delivery.name}`;
    if (delivery.isGrouped) {
      headerText += ` (${delivery.totalDocs} DOC)`;
    }
    if (isCompleted) {
      headerText = `‚úÖ ${headerText} (COMPLETATO)`;
    }
    document.getElementById('driverName').textContent = headerText;
    
    // Hide other views
    document.getElementById('statsContainer').style.display = 'none';
    document.getElementById('listView').style.display = 'none';
    document.getElementById('mapView').style.display = 'none';
    
    // Show scarico view
    document.getElementById('scaricoView').style.display = 'block';
    
    // Determina se √® solo visualizzazione:
    // - Documenti completati: solo visualizzazione
    // - Ordini residui: solo visualizzazione  
    // - Documenti da consegnare: modificabili
    const isViewOnly = isCompleted || isBackorder;
    
    // Render products
    scaricoState.isViewOnly = isViewOnly;
    renderScaricoProducts();
    updateScaricoStats();
    
    // Nascondi o mostra il pulsante Completa in base allo stato
    const completeBtn = document.getElementById('completeScaricoBtn');
    if (completeBtn) {
      if (isViewOnly) {
        completeBtn.style.display = 'none';
      } else {
        completeBtn.style.display = 'block';
      }
    }
    
  } catch (error) {
    console.error('Errore apertura scarico:', error);
    showToast('Errore: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Load Scarico Products
async function loadScaricoProducts(pickingId, appendMode = false) {
  console.log('Carico prodotti per scarico:', pickingId, appendMode ? '(append mode)' : '');
  
  if (!appendMode) {
    scaricoState.scaricoProducts = [];
  }
  
  // IMPORTANTE: Carichiamo DIRETTAMENTE le stock.move.line (operazioni dettagliate)
  // NON i stock.move!
  const moveLines = await callOdoo('stock.move.line', 'search_read', [], {
    domain: [['picking_id', '=', pickingId]],
    fields: [
      'id',
      'product_id', 
      'qty_done',         // Quantit√† effettivamente fatta
      'quantity',         // Quantit√† pianificata/prenotata (CAMPO CORRETTO!)
      'picked',           // Campo RITIRATO
      'move_id',
      'location_id',
      'location_dest_id',
      'product_uom_id'
    ],
    limit: 200
  });
  
  console.log(`Trovate ${moveLines.length} operazioni dettagliate (stock.move.line)`);
  
  // DEBUG: Logghiamo i campi per vedere cosa riceviamo
  if (moveLines.length > 0) {
    console.log('üîç DEBUG - Esempio prima move.line:', moveLines[0]);
    console.log('üîç DEBUG - Campi quantit√†:', {
      quantity: moveLines[0].quantity,
      qty_done: moveLines[0].qty_done
    });
  }
  
  // Se non ci sono move lines, proviamo a crearli dai moves
  if (moveLines.length === 0) {
    console.log('Nessuna move line trovata, carico dai moves...');
    
    const picking = await callOdoo('stock.picking', 'search_read', [], {
      domain: [['id', '=', pickingId]],
      fields: ['move_ids'],
      limit: 1
    });
    
    if (picking && picking[0].move_ids && picking[0].move_ids.length > 0) {
      const moves = await callOdoo('stock.move', 'search_read', [], {
        domain: [['id', 'in', picking[0].move_ids]],
        fields: ['product_id', 'product_uom_qty'],
        limit: 200
      });
      
      // Per ogni move, aggiungiamo un prodotto
      for (let move of moves) {
        const productId = move.product_id[0];
      
      // Get product info with category
      const productData = await callOdoo('product.product', 'search_read', [], {
        domain: [['id', '=', productId]],
        fields: ['name', 'default_code', 'barcode', 'image_128', 'categ_id'],
        limit: 1
      });
      
      const product = productData[0] || {};
      
      // Get parent category (categoria madre)
      let parentCategory = 'Secco'; // Default
      if (product.categ_id) {
        const categoryId = product.categ_id[0];
        const categoryName = product.categ_id[1];
        
        // Get parent category by looking at the complete name
        // The complete name format is "Parent / Child / SubChild"
        if (categoryName) {
          const parts = categoryName.split(' / ');
          const rootCategory = parts[0].toLowerCase();
          
          // Map to our categories
          if (rootCategory.includes('pingu')) {
            parentCategory = 'Pingu';
          } else if (rootCategory.includes('frigo')) {
            parentCategory = 'Frigo';
          } else if (rootCategory.includes('non food')) {
            parentCategory = 'NonFood';
          } else if (rootCategory.includes('secco')) {
            parentCategory = 'Secco';
          } else if (rootCategory === 'frutta e verdura') {
            // Frutta e verdura usually goes in Frigo
            parentCategory = 'Frigo';
          }
        }
      }
      
        // SALTA prodotti con quantit√† richiesta zero
        if (move.product_uom_qty === 0 || move.product_uom_qty === '0') {
          console.log(`‚è≠Ô∏è Saltando prodotto ${product.name} - quantit√† richiesta: 0`);
          continue;
        }
        
        scaricoState.scaricoProducts.push({
          id: move.id,
          moveId: move.id,
          productId: productId,
          name: product.name || move.product_id[1],
          code: product.default_code || '',
          barcode: product.barcode || '',
          image: product.image_128 || null,
          category: parentCategory,
          deliveredQty: move.product_uom_qty || 0,  // Usa la quantit√† dal move quando non ci sono lines
          returnedQty: 0,  // Parte da 0 perch√© non √® ancora stato scaricato
          completed: false
        });
      }
    }
  } else {
    // Abbiamo move lines, usiamole direttamente!
    // Prima otteniamo le informazioni dai moves per avere le quantit√† pianificate
    const moveIds = moveLines.map(line => line.move_id[0]);
    const moves = await callOdoo('stock.move', 'search_read', [], {
      domain: [['id', 'in', moveIds]],
      fields: ['id', 'product_uom_qty'],
      limit: 200
    });
    const moveQtyMap = {};
    moves.forEach(move => {
      moveQtyMap[move.id] = move.product_uom_qty;
    });
    
    for (let line of moveLines) {
      const productId = line.product_id[0];
      const moveId = line.move_id[0];
      const plannedQty = moveQtyMap[moveId] || 0;
      
      // Get product info
      const productData = await callOdoo('product.product', 'search_read', [], {
        domain: [['id', '=', productId]],
        fields: ['name', 'default_code', 'barcode', 'image_128', 'categ_id'],
        limit: 1
      });
      
      const product = productData[0] || {};
      
      // Get parent category
      let parentCategory = 'Secco';
      if (product.categ_id) {
        const categoryName = product.categ_id[1];
        if (categoryName) {
          const parts = categoryName.split(' / ');
          const rootCategory = parts[0].toLowerCase();
          
          if (rootCategory.includes('pingu')) {
            parentCategory = 'Pingu';
          } else if (rootCategory.includes('frigo')) {
            parentCategory = 'Frigo';
          } else if (rootCategory.includes('non food')) {
            parentCategory = 'NonFood';
          } else if (rootCategory.includes('secco')) {
            parentCategory = 'Secco';
          }
        }
      }
      
      // SALTA prodotti con quantit√† richiesta zero
      if (line.quantity === 0 || line.quantity === '0') {
        console.log(`‚è≠Ô∏è Saltando prodotto ${product.name} - quantit√† richiesta: 0`);
        continue;
      }
      
      // IMPORTANTE: Usiamo l'ID della LINE, non del MOVE!
      scaricoState.scaricoProducts.push({
        id: line.id,  // ID della stock.move.line!!!
        lineId: line.id,  // Teniamo anche come lineId per chiarezza
        moveId: moveId,  // ID del move associato
        productId: productId,
        name: product.name || line.product_id[1],
        code: product.default_code || '',
        barcode: product.barcode || '',
        image: product.image_128 || null,
        category: parentCategory,
        deliveredQty: line.quantity || 0,  // RICHIESTO: quantit√† pianificata dalla move.line
        returnedQty: line.qty_done || 0,  // CONSEGNATO: quantit√† effettiva
        picked: line.picked || false,  // Campo RITIRATO
        completed: line.picked || false  // Se √® picked, √® completato
      });
    }
  }
}

// Render Scarico Products
function renderScaricoProducts(filteredProducts = null) {
  const container = document.getElementById('scaricoProductGrid');
  const products = filteredProducts || scaricoState.scaricoProducts;
  
  // Clear container
  container.innerHTML = '';
  
  // Verifica lo stato del documento
  const isBackorder = scaricoState.currentDelivery && 
                     (scaricoState.currentDelivery.isBackorder || scaricoState.currentDelivery.isResiduo);
  const isCompleted = scaricoState.currentDelivery && 
                     (scaricoState.currentDelivery.completed || scaricoState.currentDelivery.state === 'done');
  
  // Mostra avviso appropriato in base allo stato
  if (isBackorder) {
    const warning = document.createElement('div');
    warning.style.cssText = 'grid-column: 1/-1; background: #fee2e2; border: 2px solid #f87171; border-radius: 8px; padding: 12px; margin: 12px; text-align: center;';
    warning.innerHTML = `
      <div style="font-size: 16px; font-weight: 600; color: #991b1b; margin-bottom: 4px;">
        üîí Ordine Residuo - Completato con Riserva
      </div>
      <div style="font-size: 13px; color: #7f1d1d;">
        I prodotti non possono essere modificati. Solo visualizzazione.
      </div>
    `;
    container.appendChild(warning);
  } else if (isCompleted && !isBackorder) {
    const warning = document.createElement('div');
    warning.style.cssText = 'grid-column: 1/-1; background: #d1fae5; border: 2px solid #10b981; border-radius: 8px; padding: 12px; margin: 12px; text-align: center;';
    warning.innerHTML = `
      <div style="font-size: 16px; font-weight: 600; color: #065f46; margin-bottom: 4px;">
        ‚úÖ Documento Completato
      </div>
      <div style="font-size: 13px; color: #047857;">
        I prodotti non possono essere modificati. Solo visualizzazione.
      </div>
    `;
    container.appendChild(warning);
  }
  
  if (products.length === 0) {
    container.innerHTML = `
      <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #9ca3af;">
        <div style="font-size: 48px; margin-bottom: 16px;">üì¶</div>
        <div>Nessun prodotto trovato</div>
      </div>
    `;
    return;
  }
  
  // Categorize products based on actual category from Odoo
  const categories = {
    Frigo: { name: '‚ùÑÔ∏è Frigo', products: [], color: '#3b82f6' },
    Pingu: { name: 'üßä Pingu (Congelato)', products: [], color: '#06b6d4' },
    Secco: { name: 'üì¶ Secco', products: [], color: '#f59e0b' },
    NonFood: { name: 'üßπ Non Food', products: [], color: '#8b5cf6' }
  };
  
  // Sort products into categories based on their actual category
  products.forEach(product => {
    const category = product.category || 'Secco';
    if (categories[category]) {
      categories[category].products.push(product);
    } else {
      // Fallback to Secco if category not recognized
      categories.Secco.products.push(product);
    }
  });
  
  // Render by category
  Object.entries(categories).forEach(([key, category]) => {
    if (category.products.length === 0) return;
    
    // Add category header
    const header = document.createElement('div');
    header.style.cssText = `grid-column: 1/-1; padding: 12px 8px 8px; font-weight: 600; color: ${category.color}; font-size: 15px; border-bottom: 2px solid ${category.color}20; margin-top: 16px;`;
    header.innerHTML = `${category.name} (${category.products.length})`;
    container.appendChild(header);
    
    // Add products in this category
    category.products.forEach(product => {
      const card = document.createElement('div');
      card.className = 'scarico-product-card' + (product.completed ? ' completed' : '');
      card.style.borderTop = `3px solid ${category.color}`;
      
      // Check if quantity was modified
      const isModified = product.returnedQty !== product.deliveredQty;
      const borderColor = isModified ? '#f59e0b' : (product.completed ? '#10b981' : '#e5e7eb');
      card.style.borderColor = borderColor;
      card.style.borderWidth = isModified ? '2px' : '1px';
      
      card.innerHTML = `
        <div class="scarico-product-image">
          ${product.image 
            ? `<img src="data:image/png;base64,${product.image}" alt="${product.name}">` 
            : 'üì¶'}
        </div>
        <div class="scarico-product-info">
          <div class="scarico-product-name">${product.name}</div>
          <div class="scarico-product-code">${product.code ? `COD: ${product.code}` : ''}</div>
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
            <span style="font-size: 10px; color: #6b7280;">RICHIESTO</span>
            <span style="font-size: 14px; font-weight: 600; color: #6b7280;">${product.deliveredQty}</span>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
            <span style="font-size: 10px; color: ${isModified ? '#f59e0b' : '#10b981'};">CONSEGNATO</span>
            <span style="font-size: 18px; font-weight: 700; color: ${isModified ? '#f59e0b' : '#10b981'};">${product.returnedQty}</span>
          </div>
          ${scaricoState.isViewOnly 
            ? `<div style="background: ${isBackorder ? '#fee2e2' : (isCompleted ? '#d1fae5' : '#e0f2fe')}; padding: 8px; border-radius: 6px; margin-top: 8px; text-align: center; font-size: 11px; color: ${isBackorder ? '#991b1b' : (isCompleted ? '#065f46' : '#0369a1')};">
                ${isBackorder ? 'üîí Bloccato' : '‚úÖ'} Quantit√†: ${product.returnedQty}
              </div>`
            : `<button class="scarico-qty-input" style="background: ${isModified ? '#fef3c7' : '#f3f4f6'}; cursor: pointer; margin-top: 8px;"
                      onclick="event.stopPropagation(); openCalculator(${product.id}, ${product.deliveredQty})">
                ‚úèÔ∏è Modifica: ${product.returnedQty}
              </button>`
          }
        </div>
      `;
      
      card.onclick = () => {
        // Se √® in modalit√† solo visualizzazione, non permettere modifiche
        if (scaricoState.isViewOnly) {
          if (isBackorder) {
            showToast('üîí Ordine residuo - Non modificabile', 'warning');
          } else if (isCompleted) {
            showToast('‚úÖ Documento completato - Non modificabile', 'info');
          }
          return;
        }
        
        // Toggle picked status
        product.picked = !product.picked;
        product.completed = product.picked;
        
        // Se viene marcato come picked e la quantit√† √® 0, imposta la quantit√† richiesta
        if (product.picked && product.returnedQty === 0) {
          product.returnedQty = product.deliveredQty;
        }
        // Se viene de-selezionato, azzera la quantit√†
        else if (!product.picked) {
          product.returnedQty = 0;
        }
        
        renderScaricoProducts();
        updateScaricoStats();
      };
      
      container.appendChild(card);
    });
  });
}

// Open Calculator
function openCalculator(productId, maxQty) {
  const product = scaricoState.scaricoProducts.find(p => p.id === productId);
  if (!product) return;
  
  let currentValue = product.returnedQty || 0;
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 360px;">
      <div class="modal-header">
        <div class="modal-title">üî¢ Inserisci Quantit√†</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 16px;">
        <div style="text-align: center; margin-bottom: 16px;">
          <div style="font-size: 14px; color: #6b7280;">Prodotto</div>
          <div style="font-size: 16px; font-weight: 600; margin-top: 4px;">${product.name}</div>
          <div style="font-size: 12px; color: #9ca3af; margin-top: 4px;">Richiesto: ${maxQty} (puoi inserire di pi√π se necessario)</div>
        </div>
        
        <div class="calculator">
          <div class="calc-display" id="calcDisplay">${currentValue}</div>
          <div class="calc-buttons">
            <button class="calc-btn" onclick="calcPress(1)">1</button>
            <button class="calc-btn" onclick="calcPress(2)">2</button>
            <button class="calc-btn" onclick="calcPress(3)">3</button>
            <button class="calc-btn" onclick="calcPress(4)">4</button>
            <button class="calc-btn" onclick="calcPress(5)">5</button>
            <button class="calc-btn" onclick="calcPress(6)">6</button>
            <button class="calc-btn" onclick="calcPress(7)">7</button>
            <button class="calc-btn" onclick="calcPress(8)">8</button>
            <button class="calc-btn" onclick="calcPress(9)">9</button>
            <button class="calc-btn" onclick="calcPressDecimal()">,</button>
            <button class="calc-btn" onclick="calcPress(0)">0</button>
            <button class="calc-btn clear" onclick="calcClear()">C</button>
            <button class="calc-btn confirm" onclick="calcConfirm(${productId})" style="grid-column: span 3;">
              ‚úÖ Conferma
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Store current calc value globally
  window.calcValue = currentValue.toString();
}

// Calculator Press
function calcPress(num) {
  if (window.calcValue === '0') {
    window.calcValue = num.toString();
  } else {
    window.calcValue += num.toString();
  }
  document.getElementById('calcDisplay').textContent = window.calcValue;
}

// Calculator Press Decimal
function calcPressDecimal() {
  // Add decimal point if not already present
  if (!window.calcValue.includes('.')) {
    window.calcValue += '.';
    document.getElementById('calcDisplay').textContent = window.calcValue;
  }
}

// Calculator Clear
function calcClear() {
  window.calcValue = '0';
  document.getElementById('calcDisplay').textContent = '0';
}

// Calculator Confirm
function calcConfirm(productId) {
  // Parse as float to handle decimals (replace comma with dot for parsing)
  const value = parseFloat(window.calcValue.replace(',', '.')) || 0;
  
  // No limit check - allow any quantity
  updateScaricoQty(productId, value);
  document.querySelector('.modal').remove();
}

// Update Scarico Quantity
function updateScaricoQty(productId, qty) {
  const product = scaricoState.scaricoProducts.find(p => p.id === productId);
  if (product) {
    // Use parseFloat instead of parseInt to handle decimals
    product.returnedQty = parseFloat(qty) || 0;
    product.completed = product.returnedQty > 0;
    updateScaricoStats();
    
    // Re-render just this card
    renderScaricoProducts();
  }
}

// Update Scarico Stats
function updateScaricoStats() {
  const total = scaricoState.scaricoProducts.length;
  const completed = scaricoState.scaricoProducts.filter(p => p.completed).length;
  const remaining = total - completed;
  
  document.getElementById('scaricoTotal').textContent = total;
  document.getElementById('scaricoCompleted').textContent = completed;
  document.getElementById('scaricoRemaining').textContent = remaining;
}

// Funzione per stampare il documento di consegna (SOLO PER CONSEGNE COMPLETATE)
async function printDelivery(deliveryId) {
  const delivery = state.deliveries.find(d => d.id === deliveryId);
  if (!delivery) return;
  
  // Verifica che sia completata
  if (delivery.state !== 'done' && !delivery.completed && !state.completedDeliveries.has(deliveryId)) {
    showToast('‚ö†Ô∏è Puoi stampare solo consegne completate', 'warning');
    return;
  }
  
  showLoading(true);
  
  // Controlla se √® una consegna raggruppata
  if (delivery.isGrouped && delivery.linkedPickings && delivery.linkedPickings.length > 1) {
    showToast(`üñ®Ô∏è Generazione ${delivery.linkedPickings.length} PDF per documenti raggruppati...`, 'info');
    console.log(`üì¶ Stampa consegna raggruppata con ${delivery.linkedPickings.length} documenti`);
    
    try {
      // Cerca i report disponibili per stock.picking
      const reports = await callOdoo('ir.actions.report', 'search_read', [], {
        domain: [
          ['model', '=', 'stock.picking'],
          ['report_type', '=', 'qweb-pdf']
        ],
        fields: ['id', 'name', 'report_name'],
        limit: 10
      });
      
      console.log('Report disponibili:', reports);
      
      // USA IL REPORT PERSONALIZZATO PER STAMPANTE 80MM
      let reportName = 'invoice_pdf_custom.report_delivery_document_customization_80mm';
      
      // Verifica se esiste nei report trovati
      if (reports && reports.length > 0) {
        const customReport = reports.find(r => 
          r.report_name === 'invoice_pdf_custom.report_delivery_document_customization_80mm' ||
          r.report_name.includes('80mm') ||
          r.report_name.includes('customization')
        );
        
        if (customReport) {
          reportName = customReport.report_name;
          console.log('‚úÖ Trovato report personalizzato 80mm:', reportName);
        } else {
          console.log('‚ö†Ô∏è Report 80mm non trovato nei report, uso nome diretto');
        }
      }
      
      console.log('Usando report:', reportName);
      const baseUrl = window.location.origin;
      
      // Scarica PDF per ogni documento del gruppo con un piccolo ritardo tra i download
      for (let i = 0; i < delivery.linkedPickings.length; i++) {
        const picking = delivery.linkedPickings[i];
        
        // Costruisci URL per scaricare direttamente il PDF
        const pdfUrl = `${baseUrl}/report/pdf/${reportName}/${picking.id}`;
        
        // Crea un link nascosto per forzare il download
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.download = `Consegna_${picking.name.replace(/\//g, '_')}.pdf`;
        link.target = '_blank';
        document.body.appendChild(link);
        
        // Aggiungi un piccolo ritardo tra i download per evitare problemi del browser
        setTimeout(() => {
          link.click();
          document.body.removeChild(link);
        }, i * 500); // 500ms di ritardo tra ogni download
        
        // Setta printed = true nel picking
        await callOdoo('stock.picking', 'write', [[picking.id], {
          printed: true
        }]);
        
        console.log(`‚úÖ PDF ${i + 1}/${delivery.linkedPickings.length} - ${picking.name}`);
      }
      
      showToast(`‚úÖ Download di ${delivery.linkedPickings.length} PDF avviato!`, 'success');
      
      // Aggiorna stato locale
      delivery.printed = true;
      renderDeliveries();
      
    } catch (error) {
      console.error('Errore stampa documenti raggruppati:', error);
      showToast('‚ùå Errore generazione PDF: ' + error.message, 'error');
    } finally {
      showLoading(false);
    }
    
  } else {
    // Documento singolo - comportamento originale
    showToast('üñ®Ô∏è Generazione PDF in corso...', 'info');
    
    try {
      // Cerca i report disponibili per stock.picking
      const reports = await callOdoo('ir.actions.report', 'search_read', [], {
        domain: [
          ['model', '=', 'stock.picking'],
          ['report_type', '=', 'qweb-pdf']
        ],
        fields: ['id', 'name', 'report_name'],
        limit: 10
      });
      
      console.log('Report disponibili:', reports);
      
      // USA IL REPORT PERSONALIZZATO PER STAMPANTE 80MM
      let reportName = 'invoice_pdf_custom.report_delivery_document_customization_80mm';
      
      // Verifica se esiste nei report trovati
      if (reports && reports.length > 0) {
        const customReport = reports.find(r => 
          r.report_name === 'invoice_pdf_custom.report_delivery_document_customization_80mm' ||
          r.report_name.includes('80mm') ||
          r.report_name.includes('customization')
        );
        
        if (customReport) {
          reportName = customReport.report_name;
          console.log('‚úÖ Trovato report personalizzato 80mm:', reportName);
        } else {
          console.log('‚ö†Ô∏è Report 80mm non trovato nei report, uso nome diretto');
        }
      }
      
      console.log('Usando report:', reportName);
      
      // Costruisci URL per scaricare direttamente il PDF
      const baseUrl = window.location.origin;
      const pdfUrl = `${baseUrl}/report/pdf/${reportName}/${deliveryId}`;
      
      // Crea un link nascosto per forzare il download
      const link = document.createElement('a');
      link.href = pdfUrl;
      link.download = `Consegna_${delivery.name.replace(/\//g, '_')}.pdf`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Setta printed = true nel picking
      await callOdoo('stock.picking', 'write', [[deliveryId], {
        printed: true
      }]);
      
      showToast('‚úÖ Download PDF avviato!', 'success');
      
      // Aggiorna stato locale
      delivery.printed = true;
      renderDeliveries();
      
    } catch (error) {
      console.error('Errore stampa:', error);
      showToast('‚ùå Errore generazione PDF: ' + error.message, 'error');
    } finally {
      showLoading(false);
    }
  }
}

// Funzione unificata per validare consegne (singole o raggruppate)
async function validateDeliveryGroup() {
  console.log('üì¶ Inizio validazione consegna/gruppo...');
  
  try {
    if (scaricoState.currentDelivery.isGrouped) {
      // GRUPPO: Valida TUTTI i documenti
      console.log(`üì¶ Validazione di ${scaricoState.currentDelivery.totalDocs} documenti raggruppati`);
      
      let successCount = 0;
      for (const picking of scaricoState.currentDelivery.linkedPickings) {
        try {
          // Prima aggiorna le quantit√† per questo picking
          const pickingProducts = scaricoState.scaricoProducts.filter(p => 
            p.pickingId === picking.id || (!p.pickingId && picking.id === scaricoState.currentDelivery.id)
          );
          
          for (const product of pickingProducts) {
            if (product.lineId) {
              await callOdoo('stock.move.line', 'write', [
                [product.lineId],
                { 
                  qty_done: product.returnedQty || 0,
                  picked: product.picked || false
                }
              ]);
            }
          }
          
          // Poi valida il picking
          await callOdoo('stock.picking', 'button_validate', [[picking.id]]);
          console.log(`‚úÖ Picking ${picking.name} validato con successo`);
          successCount++;
          
          // Marca come completato localmente
          state.completedDeliveries.add(picking.id);
          picking.completed = true;
          
        } catch (validationError) {
          console.warn(`‚ö†Ô∏è Validazione ${picking.name} non riuscita:`, validationError);
          
          // Prova con wizard se necessario
          if (validationError.data && validationError.data.name === 'odoo.exceptions.UserError') {
            try {
              const result = await callOdoo('stock.picking', 'button_validate', [[picking.id]]);
              if (result && result.res_model) {
                await callOdoo(result.res_model, 'process', [[result.res_id]]);
                console.log(`‚úÖ ${picking.name} validato tramite wizard`);
                successCount++;
                state.completedDeliveries.add(picking.id);
                picking.completed = true;
              }
            } catch (wizardError) {
              console.error(`‚ùå Anche wizard fallito per ${picking.name}:`, wizardError);
            }
          }
        }
      }
      
      showToast(`‚úÖ Validati ${successCount}/${scaricoState.currentDelivery.totalDocs} documenti`, 
                successCount === scaricoState.currentDelivery.totalDocs ? 'success' : 'warning');
      
    } else {
      // SINGOLO: Valida un solo documento
      console.log(`üì¶ Validazione singolo documento ${scaricoState.currentDelivery.name}`);
      
      // Aggiorna quantit√†
      for (const product of scaricoState.scaricoProducts) {
        if (product.lineId) {
          await callOdoo('stock.move.line', 'write', [
            [product.lineId],
            { 
              qty_done: product.returnedQty || 0,
              picked: product.picked || false
            }
          ]);
        }
      }
      
      // Valida il picking
      try {
        await callOdoo('stock.picking', 'button_validate', [[scaricoState.currentDelivery.id]]);
        console.log('‚úÖ Picking validato con successo');
      } catch (validationError) {
        console.warn('‚ö†Ô∏è Validazione non riuscita, provo con wizard:', validationError);
        
        // Prova con wizard
        try {
          const result = await callOdoo('stock.picking', 'button_validate', [[scaricoState.currentDelivery.id]]);
          if (result && result.res_model) {
            await callOdoo(result.res_model, 'process', [[result.res_id]]);
            console.log('‚úÖ Validato tramite wizard');
          }
        } catch (wizardError) {
          console.error('‚ùå Anche wizard fallito:', wizardError);
          throw wizardError;
        }
      }
      
      // Marca come completato localmente
      state.completedDeliveries.add(scaricoState.currentDelivery.id);
    }
    
    // Aggiorna stato generale
    scaricoState.currentDelivery.completed = true;
    scaricoState.currentDelivery.unloaded = true;
    
    // Ricalcola ETA
    await recalculateETAsAfterDelivery();
    
    return true;
    
  } catch (error) {
    console.error('‚ùå Errore durante validazione:', error);
    showToast('Errore validazione: ' + error.message, 'error');
    return false;
  }
}

// Handle Reso (Return)
async function handleReso(deliveryId) {
  const delivery = state.deliveries.find(d => d.id === deliveryId);
  if (!delivery) return;
  
  // Open modal for reso
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üì¶ Reso - ${delivery.name}</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 16px;">
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; color: #6b7280;">üìé Foto/Documenti del reso (consigliato)</label>
          <button onclick="if(${deliveryId}) openAttachmentModalForReso(${deliveryId}); else showToast('Errore: ID consegna mancante', 'error');" 
                  style="width: 100%; padding: 12px; background: #fef3c7; color: #92400e; border: 2px solid #fbbf24; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
            <span>üì∑üìÑ</span> Aggiungi Foto o Documenti del Reso
          </button>
          <div id="resoAttachmentsCount" style="margin-top: 8px; color: #6b7280; font-size: 14px;"></div>
        </div>
        
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; color: #6b7280;">üìù Note sul reso</label>
          <textarea id="resoNotes" style="width: 100%; padding: 8px; border: 2px solid #e5e7eb; border-radius: 8px; min-height: 100px;" placeholder="Motivo del reso, condizioni prodotto, etc."></textarea>
        </div>
        
        <button class="action-btn btn-success" id="confirmResoBtn" onclick="saveReso(${deliveryId})" style="width: 100%;">
          ‚úÖ Conferma Reso
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

// Save Reso
async function saveReso(deliveryId) {
  const notes = document.getElementById('resoNotes').value;
  
  // Recupera allegati dal nuovo sistema
  const attachments = await attachmentManager.getDeliveryAttachments(deliveryId);
  const resoAttachments = attachments.filter(a => a.context === 'reso');
  console.log(`üìé Trovati ${resoAttachments.length} allegati per il reso`);
  
  if (!notes) {
    showToast('Inserisci le note del reso', 'error');
    return;
  }
  
  // Disabilita il pulsante e mostra loading
  const confirmBtn = document.getElementById('confirmResoBtn');
  if (confirmBtn) {
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '‚è≥ Attendere...';
  }
  
  showLoading(true);
  showToast('‚è≥ Salvataggio reso in corso...', 'info');
  
  try {
    const delivery = state.deliveries.find(d => d.id === deliveryId);
    if (!delivery) throw new Error('Consegna non trovata');
    
    // 1. Ottieni informazioni sul picking per avere il partner_id
    const pickings = await callOdoo('stock.picking', 'search_read', [], {
      domain: [['id', '=', deliveryId]],
      fields: ['partner_id', 'name'],
      limit: 1
    });
    
    if (!pickings || pickings.length === 0) {
      throw new Error('Documento non trovato');
    }
    
    const partnerId = pickings[0].partner_id[0];
    
    // 2. Ottieni informazioni sul partner e il venditore
    const partners = await callOdoo('res.partner', 'search_read', [], {
      domain: [['id', '=', partnerId]],
      fields: ['user_id', 'name'],  // user_id √® il venditore
      limit: 1
    });
    
    if (!partners || partners.length === 0) {
      throw new Error('Cliente non trovato');
    }
    
    const salesUserId = partners[0].user_id ? partners[0].user_id[0] : null;
    const customerName = partners[0].name;
    
    // 3. Foto reso gestita dal nuovo sistema allegati se necessario
    let attachmentId = null;
    
    // 4. Aggiungi messaggio nel chatter del documento (RIMOSSA CREAZIONE ATTIVIT√Ä)
    try {
      const messageBody = `
        <p><strong>üì¶ RESO REGISTRATO</strong></p>
        <p><strong>Cliente:</strong> ${customerName}</p>
        <p><strong>Data:</strong> ${new Date().toLocaleString('it-IT')}</p>
        <hr/>
        <p><strong>Note del driver:</strong></p>
        <p>${notes.replace(/\n/g, '<br/>')}</p>
        ${resoAttachments.length > 0 ? `<p><strong>üìé ${resoAttachments.length} allegat${resoAttachments.length > 1 ? 'i' : 'o'} del reso</strong></p>` : ''}
        <hr/>
        <p><em>Reso registrato dal driver - Notificare il venditore</em></p>
      `;
      
      // Crea il messaggio con o senza allegato
      const messageData = {
        model: 'stock.picking',
        res_id: deliveryId,
        body: messageBody,
        message_type: 'comment',
        subtype_id: 2  // Nota interna
      };
      
      // Aggiungi l'allegato se presente
      if (attachmentId) {
        messageData.attachment_ids = [[4, attachmentId, false]];
      }
      
      const messageId = await callOdoo('mail.message', 'create', [messageData]);
      console.log('üí¨ Messaggio creato nel documento con ID:', messageId);
      
    } catch (messageError) {
      console.error('‚ö†Ô∏è Errore creazione messaggio:', messageError);
    }
    
    showToast(`‚úÖ Reso registrato con successo`, 'success');
    document.querySelector('.modal').remove();
    
  } catch (error) {
    console.error('Errore salvataggio reso:', error);
    showToast('Errore: ' + error.message, 'error');
    
    // Riabilita il pulsante in caso di errore
    const confirmBtn = document.getElementById('confirmResoBtn');
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.innerHTML = '‚úÖ Conferma Reso';
    }
  } finally {
    showLoading(false);
  }
}

// Complete Scarico - Mostra le 3 opzioni
async function completeScarico() {
  const incomplete = scaricoState.scaricoProducts.filter(p => !p.completed);
  
  if (incomplete.length > 0) {
    if (!confirm(`Ci sono ${incomplete.length} prodotti non scaricati. Completare comunque?`)) {
      return;
    }
  }
  
  // Determina se √® una consegna raggruppata
  const isGrouped = scaricoState.currentDelivery.isGrouped;
  const totalDocs = isGrouped ? scaricoState.currentDelivery.totalDocs : 1;
  
  // Mostra modal con 3 opzioni
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <div class="modal-title">üì¶ Completa Consegna - ${scaricoState.currentDelivery.name}${isGrouped ? ` (${totalDocs} DOC)` : ''}</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        <p style="text-align: center; margin-bottom: 24px; color: #6b7280;">
          Scegli come completare la consegna:
        </p>
        
        <!-- Opzione 1: Firma Cliente -->
        <button onclick="openSignatureModal()" style="width: 100%; padding: 20px; margin-bottom: 12px; background: #10b981; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 12px; cursor: pointer;">
          <span style="font-size: 24px;">‚úçÔ∏è</span>
          <div style="text-align: left;">
            <div>Firma Cliente</div>
            <div style="font-size: 12px; font-weight: 400; opacity: 0.9;">Cliente presente - Prendi la firma</div>
          </div>
        </button>
        
        <!-- Opzione 2: Solo Foto -->
        <button onclick="openPhotoOnlyModal()" style="width: 100%; padding: 20px; margin-bottom: 12px; background: #3b82f6; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 12px; cursor: pointer;">
          <span style="font-size: 24px;">üì∏</span>
          <div style="text-align: left;">
            <div>Solo Foto</div>
            <div style="font-size: 12px; font-weight: 400; opacity: 0.9;">Cliente assente - Fotografa la merce</div>
          </div>
        </button>
        
        <!-- Opzione 3: Pagamento allo Scarico -->
        <button onclick="openPaymentAtDeliveryModal()" style="width: 100%; padding: 20px; margin-bottom: 12px; background: #f59e0b; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 12px; cursor: pointer;">
          <span style="font-size: 24px;">üí∞</span>
          <div style="text-align: left;">
            <div>Pagamento allo Scarico</div>
            <div style="font-size: 12px; font-weight: 400; opacity: 0.9;">Registra pagamento ricevuto</div>
          </div>
        </button>
        
        <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 12px; margin-top: 8px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
          ‚ùå Annulla
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Initialize signature canvas
  initSignatureCanvas();
}

// Confirm scarico with signature
async function confirmScaricoWithSignature() {
  console.log('üîç DEBUG: Inizio confirmScaricoWithSignature');
  
  const canvas = document.getElementById('signatureCanvas');
  const notes = document.getElementById('deliveryNotes').value;
  
  // Recupera allegati dal nuovo sistema
  const attachments = await attachmentManager.getDeliveryAttachments(scaricoState.currentDelivery.id);
  console.log(`üìé Trovati ${attachments.length} allegati per questa consegna`);
  
  if (!canvas) {
    console.error('‚ùå Canvas non trovato!');
    showToast('Errore: Canvas firma non trovato', 'error');
    return;
  }
  
  // Check if signature is provided
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const hasSignature = imageData.data.some(channel => channel !== 0);
  
  console.log('üîç DEBUG: Ha firma?', hasSignature);
  
  if (!hasSignature) {
    showToast('La firma √® obbligatoria per completare lo scarico', 'error');
    return;
  }
  
  // Hide confirm button and show loading message
  const confirmBtn = event.target;
  confirmBtn.disabled = true;
  confirmBtn.innerHTML = '‚è≥ Attendere...';
  
  showLoading(true);
  showToast('‚è≥ Salvataggio in corso... Non chiudere!', 'info');
  
  try {
    console.log('üîç DEBUG: Preparazione firma base64');
    // Get signature as base64
    const signatureData = canvas.toDataURL('image/png').split(',')[1]; // Remove data:image/png;base64,
    console.log('üîç DEBUG: Firma base64 length:', signatureData.length);
    
    // Save signature to stock.picking
    if (!scaricoState.currentDelivery) {
      console.error('‚ùå Nessuna consegna corrente!');
      throw new Error('Nessuna consegna selezognata');
    }
    
    console.log('üîç DEBUG: Salvataggio firma per picking ID:', scaricoState.currentDelivery.id);
    console.log('üìù NOTE DA SALVARE:', notes || 'NESSUNA NOTA');
    
    // SALVA LA FIRMA COME ALLEGATO (come fa il pagamento)
    const signatureAttachmentId = await callOdoo('ir.attachment', 'create', [{
      name: `Firma_${scaricoState.currentDelivery.name}_${new Date().toISOString()}.png`,
      datas: signatureData,
      res_model: 'stock.picking',
      res_id: scaricoState.currentDelivery.id,
      type: 'binary'
    }]);
    console.log('Firma salvata come allegato:', signatureAttachmentId);
    
    // COPIO ESATTAMENTE DA "SOLO FOTO" CHE FUNZIONA!!!
    const messageHtml = `‚úçÔ∏è CONSEGNA CON FIRMA<br/>
${notes ? `Note: ${notes}<br/>` : ''}
Data: ${new Date().toLocaleString('it-IT')}<br/>
Firma allegata come prova di consegna`;
    
    try {
      // USA ESATTAMENTE LO STESSO CODICE DI "SOLO FOTO"
      await callOdoo('mail.message', 'create', [{
        model: 'stock.picking',
        res_id: scaricoState.currentDelivery.id,
        body: messageHtml,
        message_type: 'comment',
        attachment_ids: [[6, false, [signatureAttachmentId]]]
      }]);
      console.log('‚úÖ Messaggio aggiunto al picking con firma e note');
    } catch (msgError) {
      console.warn('Errore aggiunta messaggio, provo metodo alternativo:', msgError);
      
      // Metodo alternativo IDENTICO a "solo foto"
      try {
        await callOdoo('stock.picking', 'write', [[scaricoState.currentDelivery.id], {
          note: `${scaricoState.currentDelivery.note || ''}\n\n‚úçÔ∏è CONSEGNA CON FIRMA - ${new Date().toLocaleString('it-IT')}\n${notes ? `Note: ${notes}` : ''}\nFirma allegata come prova di consegna`
        }]);
        console.log('Note aggiunte al picking');
      } catch (altError) {
        console.warn('Impossibile aggiungere note:', altError);
      }
    }
    
    // PRIMA salva le quantit√† scaricate nei move lines
    showToast('üì¶ Salvataggio quantit√† prodotti...', 'info');
    console.log('üîç DEBUG: Salvataggio quantit√† prodotti scaricati');
    console.log('üîç Prodotti totali:', scaricoState.scaricoProducts.length);
    
    // Log di tutti i prodotti e le loro quantit√†
    scaricoState.scaricoProducts.forEach(p => {
      console.log(`üì¶ ${p.name}: Richiesto=${p.deliveredQty}, Consegnato=${p.returnedQty}, Differenza=${p.deliveredQty - p.returnedQty}`);
    });
    
    for (const product of scaricoState.scaricoProducts) {
      // Salva SEMPRE la quantit√†, anche se √® uguale o zero
      console.log(`üì¶ Salvo quantit√† per ${product.name}: ${product.returnedQty}`);
      
      try {
        // SEMPLICE: Abbiamo gi√† l'ID della line! Usiamolo direttamente!
        if (product.lineId) {
          console.log(`üìù Aggiorno DIRETTAMENTE move line ${product.lineId}: qty_done = ${product.returnedQty}`);
          
          // QUESTO √à IL MODO GIUSTO! Come nel picking-app!
          await callOdoo('stock.move.line', 'write', [
            [product.lineId],  // Usiamo l'ID della LINE, non del MOVE!
            { 
              qty_done: product.returnedQty,  // Scriviamo qty_done
              picked: product.picked  // Scriviamo anche il campo RITIRATO
            }
          ]);
          
          console.log(`‚úÖ Move line ${product.lineId} aggiornato con successo!`);
        } else {
          // Se non ci sono move lines, dobbiamo crearli
          console.log(`‚ö†Ô∏è Nessun move line trovato per ${product.name}, creazione nuovo...`);
          
          // Otteniamo info sul move per creare il move line
          const moves = await callOdoo('stock.move', 'search_read', [], {
            domain: [['id', '=', product.moveId]],
            fields: ['location_id', 'location_dest_id', 'product_uom'],
            limit: 1
          });
          
          if (moves.length > 0) {
            const move = moves[0];
            
            // Per consegne raggruppate, dobbiamo determinare a quale picking appartiene il move
            let pickingIdForLine = scaricoState.currentDelivery.id;
            if (scaricoState.currentDelivery.isGrouped && product.pickingId) {
              pickingIdForLine = product.pickingId;
            }
            
            // Creiamo un nuovo move line
            const newLineId = await callOdoo('stock.move.line', 'create', [{
              move_id: product.moveId,
              picking_id: pickingIdForLine,
              product_id: product.productId,
              product_uom_id: move.product_uom[0],
              location_id: move.location_id[0],
              location_dest_id: move.location_dest_id[0],
              qty_done: product.returnedQty,
              picked: product.picked  // Aggiungiamo anche il campo picked
            }]);
            
            console.log(`‚úÖ Creato nuovo move line ${newLineId} con qty_done=${product.returnedQty}`);
          }
        }
        
      } catch (moveError) {
        console.error(`‚ùå Errore aggiornamento quantit√† per ${product.name}:`, moveError);
        console.error('Dettagli errore:', moveError.message || moveError);
      }
    }
    
    // POI salva la firma - Se √® raggruppato, applica a TUTTI i documenti
    showToast('‚úçÔ∏è Salvataggio firma...', 'info');
    
    if (scaricoState.currentDelivery.isGrouped) {
      console.log('üì¶ Consegna raggruppata - Applico firma a tutti i documenti');
      
      // Applica firma e note a TUTTI i documenti del gruppo
      for (const picking of scaricoState.currentDelivery.linkedPickings) {
        console.log(`‚úçÔ∏è Salvataggio firma per documento ${picking.name} (ID: ${picking.id})`);
        
        try {
          // Salva firma per questo picking
          await callOdoo('stock.picking', 'write', [
            [picking.id],
            {
              signature: signatureData,
              is_signed: true
            }
          ]);
          console.log(`‚úÖ Firma salvata per ${picking.name}`);
          
          // Aggiungi messaggio con firma per questo picking
          try {
            const signatureAttachmentId = await callOdoo('ir.attachment', 'create', [{
              name: `Firma_${picking.name}.png`,
              datas: signatureData,
              res_model: 'stock.picking',
              res_id: picking.id,
              mimetype: 'image/png'
            }]);
            
            await callOdoo('mail.message', 'create', [{
              model: 'stock.picking',
              res_id: picking.id,
              body: `<p>‚úçÔ∏è <strong>Consegna completata con firma</strong></p>${notes ? `<p>Note: ${notes}</p>` : ''}<p>Firma allegata come prova di consegna</p>`,
              message_type: 'comment',
              attachment_ids: [[6, false, [signatureAttachmentId]]]
            }]);
          } catch (msgError) {
            console.warn(`Errore aggiunta messaggio per ${picking.name}:`, msgError);
          }
          
        } catch (signError) {
          console.error(`‚ùå Errore salvataggio firma per ${picking.name}:`, signError);
        }
      }
      
      showToast(`‚úÖ Firma salvata per ${scaricoState.currentDelivery.totalDocs} documenti!`, 'success');
      
    } else {
      // Singolo documento - comportamento originale
      try {
        await callOdoo('stock.picking', 'write', [
          [scaricoState.currentDelivery.id],
          {
            signature: signatureData,
            is_signed: true
          }
        ]);
        console.log('‚úÖ Firma salvata con successo');
        showToast('‚úÖ Firma salvata!', 'success');
      } catch (signError) {
        console.error('‚ùå Errore salvataggio firma:', signError);
        // Proviamo metodo alternativo
        console.log('üîç Tentativo metodo alternativo...');
        
        // Prova a usare il metodo action_sign se esiste
        try {
          await callOdoo('stock.picking', 'action_sign', [
            [scaricoState.currentDelivery.id],
            signatureData
          ]);
          console.log('‚úÖ Firma salvata con action_sign');
        } catch (altError) {
          console.error('‚ùå Anche metodo alternativo fallito:', altError);
          throw signError; // Rilancia errore originale
        }
      }
    }
    
    // Gli allegati (incluse foto) sono gi√† stati gestiti dal nuovo sistema
    // Non serve pi√π gestire photo qui perch√© √® stata sostituita dal sistema allegati unificato
    if (false) { // Disabilitato - usa il nuovo sistema allegati
      console.log('üîç DEBUG: Salvataggio foto allegata');
      const reader = new FileReader();
      const photoPromise = new Promise((resolve, reject) => {
        reader.onload = async function(e) {
          try {
            const photoBase64 = e.target.result.split(',')[1];
            console.log('üîç DEBUG: Foto base64 length:', photoBase64.length);
            
            // Se √® raggruppato, salva foto per TUTTI i documenti
            if (scaricoState.currentDelivery.isGrouped && scaricoState.currentDelivery.linkedPickings) {
              console.log(`üì∏ Salvataggio foto per ${scaricoState.currentDelivery.linkedPickings.length} documenti raggruppati`);
              
              for (const picking of scaricoState.currentDelivery.linkedPickings) {
                try {
                  // Create attachment per ogni documento
                  const photoAttachmentId = await callOdoo('ir.attachment', 'create', [{
                    name: `Consegna_${picking.name}_foto.jpg`,
                    datas: photoBase64,
                    res_model: 'stock.picking',
                    res_id: picking.id,
                    mimetype: 'image/jpeg'
                  }]);
                  
                  // Aggiungi messaggio con foto per ogni documento
                  const messageHtml = `<p>üì∏ <strong>Consegna completata con firma e foto</strong></p>
                    ${notes ? `<p>Note: ${notes}</p>` : ''}
                    <p>Data: ${new Date().toLocaleString('it-IT')}</p>
                    <p>Foto allegata come prova di consegna</p>`;
                  
                  await callOdoo('mail.message', 'create', [{
                    model: 'stock.picking',
                    res_id: picking.id,
                    body: messageHtml,
                    message_type: 'comment',
                    attachment_ids: [[6, false, [photoAttachmentId]]]
                  }]);
                  
                  console.log(`‚úÖ Foto salvata e messaggio aggiunto per ${picking.name}`);
                } catch (photoError) {
                  console.error(`‚ùå Errore salvataggio foto per ${picking.name}:`, photoError);
                }
              }
              
              showToast(`üì∏ Foto salvata per ${scaricoState.currentDelivery.totalDocs} documenti!`, 'success');
              
            } else {
              // Singolo documento - comportamento originale
              const photoAttachmentId = await callOdoo('ir.attachment', 'create', [{
                name: `Consegna_${scaricoState.currentDelivery.name}_foto.jpg`,
                datas: photoBase64,
                res_model: 'stock.picking',
                res_id: scaricoState.currentDelivery.id,
                mimetype: 'image/jpeg'
              }]);
              
              // Aggiungi messaggio con foto
              const messageHtml = `<p>üì∏ <strong>Consegna completata con firma e foto</strong></p>
                ${notes ? `<p>Note: ${notes}</p>` : ''}
                <p>Data: ${new Date().toLocaleString('it-IT')}</p>
                <p>Foto allegata come prova di consegna</p>`;
              
              await callOdoo('mail.message', 'create', [{
                model: 'stock.picking',
                res_id: scaricoState.currentDelivery.id,
                body: messageHtml,
                message_type: 'comment',
                attachment_ids: [[6, false, [photoAttachmentId]]]
              }]);
              
              console.log('‚úÖ Foto allegata con successo e messaggio aggiunto');
            }
            
            resolve();
          } catch (err) {
            console.error('‚ùå Errore allegato foto:', err);
            reject(err);
          }
        };
        reader.onerror = reject;
      });
      reader.readAsDataURL(photo);
      await photoPromise;
    }
    
    // Usa la funzione unificata per validare (gestisce singoli e gruppi)
    showToast('üì¶ Validazione documenti...', 'info');
    const validationSuccess = await validateDeliveryGroup();
    
    if (validationSuccess) {
      showToast('‚úÖ Scarico completato e firmato con successo!', 'success');
    } else {
      showToast('‚ö†Ô∏è Alcuni documenti potrebbero non essere stati validati', 'warning');
    }
    
    // Close modal and go back
    console.log('üîç DEBUG: Chiusura modal e ritorno alla lista');
    document.querySelectorAll('.modal').forEach(m => m.remove());
    setTimeout(() => {
      closeScaricoView();
      renderDeliveries();
      updateStats();
    }, 1500);
    
  } catch (error) {
    console.error('‚ùå ERRORE GENERALE:', error);
    console.error('Stack:', error.stack);
    showToast('Errore: ' + (error.message || 'Errore sconosciuto'), 'error');
  } finally {
    showLoading(false);
  }
}


// Close Scarico View
function closeScaricoView() {
  // Hide scarico view
  document.getElementById('scaricoView').style.display = 'none';
  
  // Show list view
  document.getElementById('statsContainer').style.display = 'grid';
  document.getElementById('listView').style.display = 'block';
  
  // Reset header
  if (state.employeeName) {
    document.getElementById('driverName').textContent = state.employeeName;
  }
  
  // Clear scarico state
  scaricoState = {
    currentDelivery: null,
    scaricoProducts: []
  };
  
  // Re-render deliveries
  renderDeliveries();
}

// Override switchView to handle scarico view
const _originalSwitchView = switchView;
window.switchView = function(view) {
  // If scarico view is open, close it first
  const scaricoView = document.getElementById('scaricoView');
  if (scaricoView && scaricoView.style.display !== 'none') {
    closeScaricoView();
  }
  
  // Call original function
  _originalSwitchView(view);
};



// Funzione per aprire modal firma cliente
function openSignatureModal() {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <div class="modal-title">‚úçÔ∏è Firma Cliente</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
          <strong>‚úÖ Cliente Presente</strong><br>
          <span style="font-size: 14px; color: #065f46;">
            Fai firmare al cliente per confermare la consegna
          </span>
        </div>
        
        <!-- Canvas per la firma -->
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
            ‚úçÔ∏è Firma del Cliente <span style="color: #ef4444;">*</span>
          </label>
          <canvas id="signatureCanvas" 
                  style="width: 100%; height: 200px; border: 2px solid #e5e7eb; border-radius: 8px; background: white; touch-action: none;">
          </canvas>
          <button onclick="clearSignature()" style="margin-top: 8px; padding: 6px 12px; background: #6b7280; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
            üóëÔ∏è Cancella Firma
          </button>
        </div>
        
        <!-- Allegati con sistema unificato -->
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
            üìé Allegati (opzionale)
          </label>
          <button onclick="if(scaricoState?.currentDelivery?.id) openAttachmentModalForSignature(); else showToast('Seleziona prima una consegna', 'error');" 
                  style="width: 100%; padding: 12px; background: #f3f4f6; color: #1f2937; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
            <span>üì∑üìÑ</span> Aggiungi Foto o Documenti
          </button>
          <div id="selectedAttachmentsCount" style="margin-top: 8px; color: #6b7280; font-size: 14px;"></div>
        </div>
        
        <!-- Note -->
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
            üìù Note (opzionale)
          </label>
          <textarea id="deliveryNotes" placeholder="Note aggiuntive..." 
                    style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 8px; min-height: 60px; resize: vertical;"></textarea>
        </div>
        
        <!-- Conferma -->
        <button onclick="confirmScaricoWithSignature()" style="width: 100%; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
          ‚úÖ Conferma Consegna con Firma
        </button>
        
        <!-- Annulla -->
        <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 12px; margin-top: 8px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
          ‚ùå Annulla
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Initialize signature canvas
  initSignatureCanvas();
}

// Funzione per aprire modal solo foto (senza firma)
function openPhotoOnlyModal() {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <div class="modal-title">üì∏ Foto Consegna (Senza Firma)</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        <div style="background: #e0f2fe; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
          <strong>‚ÑπÔ∏è Cliente Assente</strong><br>
          <span style="font-size: 14px; color: #0369a1;">
            Scatta una foto della merce consegnata come prova di avvenuta consegna
          </span>
        </div>
        
        <!-- Allegati con sistema unificato (almeno 1 obbligatorio) -->
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
            üìé Foto/Documenti Consegna <span style="color: #ef4444;">* (almeno 1 obbligatorio)</span>
          </label>
          <button onclick="if(scaricoState?.currentDelivery?.id) openAttachmentModalForPhoto(); else showToast('Seleziona prima una consegna', 'error');" 
                  style="width: 100%; padding: 12px; background: #e0f2fe; color: #0369a1; border: 2px solid #7dd3fc; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
            <span>üì∑üìÑ</span> Aggiungi Foto o Documenti
          </button>
          <div id="photoOnlyAttachmentsCount" style="margin-top: 8px; color: #6b7280; font-size: 14px;"></div>
          <small style="color: #dc2626;">Devi aggiungere almeno una foto o documento come prova di consegna</small>
        </div>
        
        <!-- Note -->
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
            üìù Note (opzionale)
          </label>
          <textarea id="photoOnlyNotes" placeholder="Es: Merce lasciata presso..." 
                    style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 8px; min-height: 80px; resize: vertical;"></textarea>
        </div>
        
        <!-- Conferma -->
        <button onclick="confirmScaricoPhotoOnly()" style="width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
          ‚úÖ Conferma Consegna
        </button>
        
        <!-- Annulla -->
        <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 12px; margin-top: 8px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
          ‚ùå Annulla
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

// Conferma scarico con solo foto
async function confirmScaricoPhotoOnly() {
  const notes = document.getElementById('photoOnlyNotes').value;
  
  // Recupera allegati dal nuovo sistema
  const attachments = await attachmentManager.getDeliveryAttachments(scaricoState.currentDelivery.id);
  
  if (!attachments || attachments.length === 0) {
    showToast('Devi aggiungere almeno una foto o documento per completare la consegna', 'error');
    return;
  }
  
  // Verifica che scaricoState sia inizializzato
  if (!scaricoState || !scaricoState.currentDelivery) {
    showToast('Errore: stato consegna non valido', 'error');
    return;
  }
  
  const confirmBtn = event.target;
  confirmBtn.disabled = true;
  confirmBtn.innerHTML = '‚è≥ Attendere...';
  
  showLoading(true);
  showToast('‚è≥ Salvataggio in corso...', 'info');
  
  try {
    // Salva quantit√† prodotti solo se ci sono prodotti da aggiornare
    if (scaricoState.scaricoProducts && scaricoState.scaricoProducts.length > 0) {
      for (const product of scaricoState.scaricoProducts) {
        if (product.lineId && product.returnedQty !== undefined) {
          try {
            await callOdoo('stock.move.line', 'write', [
              [product.lineId],
              { 
                qty_done: product.returnedQty || 0,
                picked: product.picked || false
              }
            ]);
          } catch (lineError) {
            console.error(`Errore aggiornamento linea ${product.lineId}:`, lineError);
            // Continua con le altre linee anche se una fallisce
          }
        }
      }
    }
    
    // Gli allegati sono gi√† stati gestiti dal sistema unificato
    console.log(`üìé ${attachments.length} allegati pronti per la sincronizzazione`);
    
    // Aggiungi messaggio nel chatter
    const messageHtml = `üì∏ CONSEGNA SENZA FIRMA (cliente assente)<br/>
${notes ? `Note: ${notes}<br/>` : ''}
Data: ${new Date().toLocaleString('it-IT')}<br/>
${attachments.length} allegat${attachments.length > 1 ? 'i' : 'o'} come prova di consegna`;
    
    try {
      await callOdoo('mail.message', 'create', [{
        model: 'stock.picking',
        res_id: scaricoState.currentDelivery.id,
        body: messageHtml,
        message_type: 'comment'
      }]);
      console.log('Messaggio aggiunto al picking');
    } catch (msgError) {
      console.warn('Errore aggiunta messaggio, provo metodo alternativo:', msgError);
      
      // Metodo alternativo: aggiorna note nel picking
      try {
        await callOdoo('stock.picking', 'write', [[scaricoState.currentDelivery.id], {
          note: `${scaricoState.currentDelivery.note || ''}\n\nüì∏ CONSEGNA SENZA FIRMA - ${new Date().toLocaleString('it-IT')}\n${notes ? `Note: ${notes}` : ''}\nFoto allegata come prova di consegna`
        }]);
        console.log('Note aggiunte al picking');
      } catch (altError) {
        console.warn('Impossibile aggiungere note:', altError);
      }
    }
    
    // Usa la funzione unificata per validare (gestisce singoli e gruppi)
    showToast('üì¶ Chiusura documento in Odoo...', 'info');
    const validationSuccess = await validateDeliveryGroup();
    
    if (validationSuccess) {
      showToast('‚úÖ Consegna completata e chiusa con foto!', 'success');
    } else {
      showToast('‚ö†Ô∏è Alcuni documenti potrebbero non essere stati validati', 'warning');
    }
    
    // Salva stato in localStorage
    try {
      const stateToSave = {
        completedDeliveries: Array.from(state.completedDeliveries)
      };
      localStorage.setItem('deliveryAppState', JSON.stringify(stateToSave));
    } catch (saveError) {
      console.warn('Impossibile salvare stato:', saveError);
    }
    
    // Chiudi modal e torna alla lista
    document.querySelectorAll('.modal').forEach(m => m.remove());
    setTimeout(() => {
      closeScaricoView();
      renderDeliveries();
      updateStats();
    }, 1500);
    
  } catch (error) {
    console.error('Errore:', error);
    showToast('Errore: ' + error.message, 'error');
  } finally {
    showLoading(false);
  }
}

// Funzione per aprire modal pagamento allo scarico
function openPaymentAtDeliveryModal() {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <div class="modal-title">üí∞ Pagamento allo Scarico</div>
        <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
      </div>
      
      <div style="padding: 20px;">
        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
          <strong>üì± Fattura via WhatsApp</strong><br>
          <span style="font-size: 14px; color: #92400e;">
            Questa operazione chiuder√† il documento OUT.<br>
            La fattura verr√† generata automaticamente e<br>
            riceverai il link via WhatsApp.
          </span>
        </div>
        
        <div style="background: #e0f2fe; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
          <strong>üí≥ Metodi di pagamento accettati</strong><br>
          <span style="font-size: 14px; color: #0369a1;">
            ‚Ä¢ Contanti<br>
            ‚Ä¢ Bancomat/Carta<br>
            ‚Ä¢ Bonifico immediato<br>
            ‚Ä¢ Assegno
          </span>
        </div>
        
        <!-- Conferma -->
        <button onclick="processPaymentAtDelivery()" style="width: 100%; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
          üí∞ Registra Pagamento Ricevuto
        </button>
        
        <!-- Annulla -->
        <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 12px; margin-top: 8px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
          ‚ùå Annulla
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

// Processa pagamento allo scarico - VERSIONE SENZA GENERAZIONE FATTURA MA CON FLUSSO ORIGINALE
async function processPaymentAtDelivery() {
  const confirmBtn = event.target;
  confirmBtn.disabled = true;
  confirmBtn.innerHTML = '‚è≥ Elaborazione...';
  
  showLoading(true);
  showToast('‚è≥ Chiusura OUT in corso...', 'info');
  
  try {
    // 1. PRIMA salva le quantit√†
    for (const product of scaricoState.scaricoProducts) {
      if (product.lineId) {
        await callOdoo('stock.move.line', 'write', [
          [product.lineId],
          { 
            qty_done: product.returnedQty,
            picked: product.picked
          }
        ]);
      }
    }
    
    // 2. POI valida il picking/gruppo (chiude WH/OUT) - Usa la funzione unificata
    showToast('üì¶ Chiusura documento OUT...', 'info');
    const validationSuccess = await validateDeliveryGroup();
    
    if (!validationSuccess) {
      showToast('‚ö†Ô∏è Alcuni documenti potrebbero non essere stati chiusi', 'warning');
      // Continua comunque per registrare il pagamento
    }
    
    // 3. DOPO LA CHIUSURA, mostra il modal per inserire i dati del pagamento
    showLoading(false);
    document.querySelectorAll('.modal').forEach(m => m.remove());
    
    const paymentModal = document.createElement('div');
    paymentModal.className = 'modal active';
    paymentModal.innerHTML = `
      <div class="modal-content" style="max-width: 450px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <div class="modal-title">üí∞ Registra Pagamento Ricevuto</div>
          <div class="modal-close" onclick="this.closest('.modal').remove()">√ó</div>
        </div>
        
        <div style="padding: 20px;">
          <!-- Info consegna -->
          <div style="background: #d4f4dd; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
            <div style="font-size: 14px; color: #166534;">
              <strong>‚úÖ OUT CHIUSO CON SUCCESSO!</strong><br>
              <strong>üì¶ Documento:</strong> ${scaricoState.currentDelivery.name}<br>
              <strong>üë§ Cliente:</strong> ${scaricoState.currentDelivery.customer}<br>
              <strong>üì± La fattura verr√† inviata via WhatsApp</strong>
            </div>
          </div>
          
          <!-- Allegati pagamento con sistema unificato (almeno 1 obbligatorio) -->
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
              üìé Foto/Documenti Pagamento <span style="color: #ef4444;">* (almeno 1 obbligatorio)</span>
            </label>
            <button onclick="if(scaricoState?.currentDelivery?.id) openAttachmentModalForPayment(); else showToast('Seleziona prima una consegna', 'error');" 
                    style="width: 100%; padding: 12px; background: #fef3c7; color: #92400e; border: 2px solid #fbbf24; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <span>üì∑üìÑ</span> Aggiungi Foto Pagamento o Ricevute
            </button>
            <div id="paymentAttachmentsCount" style="margin-top: 8px; color: #6b7280; font-size: 14px;"></div>
            <small style="color: #dc2626;">Fotografa contanti/assegno/ricevuta POS o carica documenti</small>
          </div>
          
          <!-- Importo riscosso -->
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
              üíµ Importo Riscosso <span style="color: #ef4444;">*</span>
            </label>
            <input type="number" id="collectedAmount" step="0.01" placeholder="0.00" required
                   style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 18px; font-weight: 600;">
          </div>
          
          <!-- Metodo di pagamento -->
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
              üí≥ Metodo di Pagamento
            </label>
            <select id="paymentMethod" style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px;">
              <option value="contanti">üíµ Contanti</option>
              <option value="carta">üí≥ Carta/Bancomat</option>
              <option value="assegno">üìù Assegno</option>
              <option value="bonifico">üè¶ Bonifico</option>
            </select>
          </div>
          
          <!-- Note -->
          <div style="margin-bottom: 16px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937;">
              üìù Note
            </label>
            <textarea id="paymentNotes" placeholder="Es: Resto dato ‚Ç¨50, pagato con bancomat..." 
                      style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 8px; min-height: 80px; resize: vertical;"></textarea>
          </div>
          
          <!-- Bottoni -->
          <button onclick="savePaymentData()" style="width: 100%; padding: 14px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 18px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">
            ‚úÖ Salva Dati Pagamento
          </button>
          
          <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 10px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
            ‚ùå Annulla
          </button>
        </div>
      </div>
    `;
    document.body.appendChild(paymentModal);
    
  } catch (error) {
    console.error('Errore preparazione pagamento:', error);
    showToast('Errore: ' + error.message, 'error');
    showLoading(false);
  }
}

// Funzione per salvare i dati del pagamento nel chatter (OUT gi√† chiuso)
async function savePaymentData() {
  const collectedAmount = parseFloat(document.getElementById('collectedAmount').value);
  const paymentMethod = document.getElementById('paymentMethod').value;
  const notes = document.getElementById('paymentNotes').value;
  
  // Recupera allegati dal nuovo sistema
  const attachments = await attachmentManager.getDeliveryAttachments(scaricoState.currentDelivery.id);
  
  // Validazione campi obbligatori
  if (!attachments || attachments.length === 0) {
    showToast('üì∑ Devi aggiungere almeno una foto o documento del pagamento', 'error');
    return;
  }
  
  if (!collectedAmount || collectedAmount <= 0) {
    showToast('üíµ Inserisci l\'importo riscosso', 'error');
    return;
  }
  
  const confirmBtn = event.target;
  confirmBtn.disabled = true;
  confirmBtn.innerHTML = '‚è≥ Salvataggio in corso...';
  
  showLoading(true);
  showToast('üíæ Salvataggio dati pagamento...', 'info');
  
  try {
    // Gli allegati del pagamento sono gi√† stati gestiti dal sistema unificato
    console.log(`üìé ${attachments.length} allegati pagamento pronti per la sincronizzazione`);
    
    // 3. Prepara messaggio dettagliato per il chatter
    const paymentMethodLabels = {
      'contanti': 'üíµ Contanti',
      'carta': 'üí≥ Carta/Bancomat',
      'assegno': 'üìù Assegno',
      'bonifico': 'üè¶ Bonifico'
    };
    
    const messageHtml = `
      <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin: 8px 0;">
        <strong>üí∞ PAGAMENTO ALLO SCARICO RICEVUTO</strong><br/>
        <hr style="margin: 8px 0; border: none; border-top: 1px solid #f59e0b;"/>
        <strong>üìÖ Data/Ora:</strong> ${new Date().toLocaleString('it-IT')}<br/>
        <strong>üíµ Importo Riscosso:</strong> <span style="font-size: 18px; color: #92400e;">‚Ç¨ ${collectedAmount.toFixed(2)}</span><br/>
        <strong>üí≥ Metodo:</strong> ${paymentMethodLabels[paymentMethod] || paymentMethod}<br/>
        ${notes ? `<strong>üìù Note:</strong> ${notes}<br/>` : ''}
        <strong>üì∑ Allegati:</strong> ${attachments.length} file come prova di pagamento<br/>
        <strong>üì± Stato:</strong> La fattura verr√† inviata via WhatsApp
      </div>
    `;
    
    // 4. Aggiungi messaggio nel chatter del documento OUT
    try {
      await callOdoo('mail.message', 'create', [{
        model: 'stock.picking',
        res_id: scaricoState.currentDelivery.id,
        body: messageHtml,
        message_type: 'comment',
        // Gli allegati sono gestiti separatamente dal sistema unificato
      }]);
      console.log('‚úÖ Messaggio pagamento aggiunto al chatter');
    } catch (msgError) {
      console.warn('‚ö†Ô∏è Errore nel chatter, salvo nelle note:', msgError);
      
      // Fallback: salva nelle note del documento
      await callOdoo('stock.picking', 'write', [[scaricoState.currentDelivery.id], {
        note: `${scaricoState.currentDelivery.note || ''}\n\nüí∞ PAGAMENTO RICEVUTO - ${new Date().toLocaleString('it-IT')}\nImporto: ‚Ç¨ ${collectedAmount.toFixed(2)}\nMetodo: ${paymentMethodLabels[paymentMethod]}\n${notes ? `Note: ${notes}` : ''}\nFoto pagamento allegata al documento`
      }]);
    }
    
    // 5. Marca come completato nella UI (l'OUT √® gi√† stato chiuso prima)
    state.completedDeliveries.add(scaricoState.currentDelivery.id);
    const deliveryIndex = state.deliveries.findIndex(d => d.id === scaricoState.currentDelivery.id);
    if (deliveryIndex !== -1) {
      state.deliveries[deliveryIndex].completed = true;
    }
    
    // 6. Salva stato locale
    try {
      const stateToSave = {
        completedDeliveries: Array.from(state.completedDeliveries)
      };
      localStorage.setItem('deliveryAppState', JSON.stringify(stateToSave));
    } catch (saveError) {
      console.warn('Impossibile salvare stato locale:', saveError);
    }
    
    // 7. Chiudi tutti i modal e aggiorna UI
    showToast('‚úÖ Pagamento registrato con successo!', 'success');
    document.querySelectorAll('.modal').forEach(m => m.remove());
    
    // Torna alla vista scarico o lista
    closeScaricoView();
    renderDeliveries();
    updateStats();
    
  } catch (error) {
    console.error('‚ùå Errore salvataggio pagamento:', error);
    showToast('Errore: ' + error.message, 'error');
    confirmBtn.disabled = false;
    confirmBtn.innerHTML = '‚úÖ Salva Dati Pagamento';
  } finally {
    showLoading(false);
  }
}

// FUNZIONE RIMOSSA: confirmPaymentCollection non pi√π utilizzata nel nuovo flusso
// Il pagamento allo scarico ora usa savePaymentData() senza generazione fattura

// Funzione per chiudere dopo fattura
function closeAfterInvoice() {
  document.querySelectorAll('.modal').forEach(m => m.remove());
  closeScaricoView();
  renderDeliveries();
  updateStats();
  showToast('‚úÖ Consegna completata con successo!', 'success');
  
  // Ricalcola ETA per le consegne rimanenti
  recalculateETAsAfterDelivery();
}

// Callback per Google Maps
function initAfterMapsLoad() {
  // Google Maps √® caricato, inizializza quando il DOM √® pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
}

// Start app - Rimosso perch√© ora viene chiamato da Google Maps callback
// window.addEventListener('DOMContentLoaded', init);
</script>


<script async="" defer="" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDQbkXsAyNQs0NypjDgTGA_SUxFxJWmijk&amp;callback=initAfterMapsLoad">
</script>